\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Deque de Kaplan e Tarjan} \label{cap:deque3_persist}

Apresentaremos neste capítulo uma modificação da implementação do Capítulo~\ref{cap:deque2_persist} para que todas as operações, exceto~\textsc{k-th}, consumam tempo e espaço~$\Oh(1)$. Esta implementação foi inicialmente apresentada por Kaplan e Tarjan~\cite{KaplanT1999}.

Assim como na deque recursiva do Capítulo~\ref{cap:deque2_persist}, a estrutura da deque deste capítulo será composta por níveis, cada um armazenando um prefixo e um sufixo da deque, e um ponteiro para o próximo nível da deque, que armazena pares dos elementos desse nível. A diferença se dá pois, em vez de o prefixo e sufixo armazenarem zero ou um elemento, como na deque recursiva, nesta estrutura o prefixo e sufixo armazenam de zero a cinco elementos. Uma estratégia é usada para tentar manter cada uma destas extremidades balanceadas, de forma que seja possível executar as operações de forma mais rápida, já que em geral será possível adicionar ou remover um elemento alterando apenas o primeiro nível. Observe a Figura~\ref{fig:deque3_ex} e suas similaridades com a Figura~\ref{fig:deque_ex}.

Para apresentar esta estratégia, na Seção~\ref{sec:contbin} observamos a similaridade das operações nessas estruturas com a operação de incremento em contadores binários e então, analisando um algoritmo mais eficiente de incremento em contadores binários, é possível utilizar a mesma ideia para tornar a implementação da deque mais eficiente.

\section{Contadores binários} \label{sec:contbin}

\subsection{Deque persistente como um contador binário} \label{subsec:contbin_simples}

Note que, na estrutura do Capítulo~\ref{cap:deque2_persist}, se adicionarmos elementos apenas usando~\funcAPI{PushFront}{d, x}, o primeiro nível da estrutura é visitado em todas as adições, o segundo nível é visitado a cada duas adições, o terceiro a cada quatro, e assim por diante.

Esse comportamento é similar à operação de incrementar~1 em um contador binário. Podemos considerar que cada nível da estrutura do Capítulo~\ref{cap:deque2_persist} é um dígito:~0 se~$\V{prefix}$ do nível é nulo ou~1 se~$\V{prefix}$ do nível é não nulo. O primeiro nível é o dígito menos significativo. Assim, adicionar um elemento usando~\funcAPI{PushFront}{d, x} é equivalente a incrementar de~1 o contador binário:
se o dígito menos significativo é~0, esse dígito se torna~1; se ele é~1, então ele vira~0 e propagamos o aumento de~1 para o próximo dígito. Em~\funcAPI{PushFront}{d, x}, se~$\V{prefix}$ é nulo, então~$\V{prefix}$ passa a apontar para~$x$; senão, ele passa a valer~\keyword{null} e formamos um par com~$x$ e o elemento que era apontado por~$\V{prefix}$, e incluímos esse par no próximo nível da estrutura.

Apesar de sabermos que incrementar~1 em um contador binário consome tempo amortizado~$\Oh(1)$, sabemos que algumas vezes incrementar~1 pode levar tempo~$\Theta(\lg n)$, onde~$n$ é o valor máximo que o contador atinge. Como estamos em uma estrutura persistente, podemos efetuar essa operação cara repetidas vezes na mesma versão, e não é possível manter o custo amortizado~$\Oh(1)$.

\subsection{Contadores binários redundantes} \label{subsec:contbin_redun}

Contadores binários redundantes são contadores binários nos quais cada dígito pode ser 0,~1 ou~2. Ainda como em um contador normal, se o contador redundante tem~$b$ dígitos~$x_0, x_1, \ldots, x_{b-1}$, então o seu valor é~$\sum\limits_{i=0}^{b-1}{x_i 2^i}$. Ao permitirmos dígitos~2, passam a existir diversas formas de representar o mesmo número. Por exemplo, o número 9 pode ser representado como 1001, 201 ou 121.

Dizemos que um contador binário redundante~$x$ é~\deff{semirregular} se, entre quaisquer dígitos~2, existe um dígito~0, ou seja, se~${x_i = 2}$,~${x_j = 2}$ e~$i < j$, então existe~$k$ tal que~${x_k = 0}$ e~${i < k < j}$. Se também existe um~0 entre o primeiro~2 e o começo do contador (dígito menos significativo), dizemos que o contador é~\deff{regular}. Um contador com apenas 0s é claramente regular, e vamos mostrar como incrementar de~1 um contador binário regular mudando apenas~$\Oh(1)$ dígitos e mantendo sua regularidade.

Suponha que temos um contador binário regular, e queremos incrementá-lo de~1. Pela regularidade,~${x_0 < 2}$, e portanto é possível incrementar esse dígito sem causar um estouro. No entanto, ao fazer isso, o contador pode deixar de ser regular, apesar de ainda ser semirregular, pois é possível que não exista mais nenhum~0 antes do primeiro dígito~2. Procuramos então o primeiro dígito~2 e, se um tal dígito existir, realizamos um procedimento~\textsc{Fix} nele. Se não existir nenhum dígito~2, o contador é regular.

Caso exista, seja~$i$ o índice do primeiro dígito~2. Um procedimento~\textsc{Fix} consiste em transformar esse dígito em~0 e incrementar de~1 o dígito~$i+1$. Se isso for possível, é claro que o valor representado pelo contador continua o mesmo, pois~$2^i x_i + 2^{i+1} x_{i+1} = 2^i (x_i - 2) + 2^{i+1} (x_{i+1} + 1)$.

A Figura~\ref{fig:cont_ex} mostra os casos possíveis em que se realiza o procedimento~\textsc{Fix}. O lado esquerdo representa como eram os dígitos antes do incremento e o lado direito, depois do incremento. O dígito na posição~$j$, nos Casos~2 e~3, é o segundo dígito~2. À direita do último dígito representado, temos que o contador é semirregular.

\begin{figure}[h]
\centering

\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells},
column 1/.style={nodes={draw=none}},
row 1/.style={nodes={draw=none}},
row 2 column 6/.style={nodes={draw=none}}
]

\matrix[array] (array) {
       &        & $i$ & & &  & & $i$  \\
Caso 1\ \  & \ldots & 2 & 0/1 & \ldots & \hspace{.8cm}$\Rightarrow$\hspace{.8cm} &
             \ldots & 0 & 1/2 & \ldots  \\
 };
\end{tikzpicture}

\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells},
column 1/.style={nodes={draw=none}},
row 1/.style={nodes={draw=none}},
row 2 column 7/.style={nodes={draw=none}}
]

\matrix[array] (array) {
       &        & $i$ & & & $j$ & & & $i$ & & & $j$ \\
Caso 2\ \  & \ldots & 2 & 0 & \ldots & 2 & \hspace{.8cm}$\Rightarrow$\hspace{.8cm} &
             \ldots & 0 & 1 & \ldots & 2  \\
 };
\end{tikzpicture}

\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells},
column 1/.style={nodes={draw=none}},
row 1/.style={nodes={draw=none}},
row 2 column 9/.style={nodes={draw=none}}
]

\matrix[array] (array) {
 & & $i$ & & & & & $j$ & & & $i$ & & & & & $j$ \\
Caso 3\ \  & \ldots & 2 & 1 & \ldots & 0 & \ldots & 2 & \hspace{.8cm}$\Rightarrow$\hspace{.8cm} &
             \ldots & 0 & 2 & \ldots & 0 & \ldots & 2 \\
 };
\end{tikzpicture}

\caption{Casos possíveis para o procedimento~\textsc{Fix}. O~``$\ldots$'' representa zero ou mais dígitos~0 ou~1.} \label{fig:cont_ex}
\end{figure}

No Caso~1, o resultado ou não tem dígito~2, ou tem um dígito~2 com um~0 imediatamente à sua esquerda, logo o contador continua regular. No Caso~2, quando o dígito~$i + 1$ é~0, o resultado tem o dígito~$i$ como~0, e o dígito~$j$ como o primeiro~2, logo a regularidade é respeitada. No Caso~3, o dígito~$i+1$ passa a ser o primeiro~2, mas como ele era anteriormente~1, ainda existe um~0 antes da posição~$j$. Além disso, o dígito~$i$ é~0, logo a regularidade é respeitada.

O contador portanto continua regular, alterando no máximo três dígitos~($x_0,\ x_i$ e~$x_{i+1}$). Para encontrar o primeiro~2 em tempo constante, podemos manter uma pilha com todos os índices de dígitos que são~2. Vamos esboçar um código para fazer esse incremento. Suponha que temos uma pilha~$p$ implementada como a do~Capítulo~\ref{cap:pilha_persist}, e que o contador é armazenado em um vetor~$x$, indexado a partir de~0.


\begin{algorithm}
\begin{algorithmic}[1]

\Function{Add1}{$x, p$}
    \State $x_0 = x_0 + 1$
    \If{$x_0 = 2$}
        \State $p = \Call{Push}{p, 0}$
    \EndIf
    \If{$p \neq \Null$} \Comment{\textsc{Fix} no primeiro dígito~2}
        \State $i = \Call{Top}{p}$
        \State $p = \Call{Pop}{p}$
        \State $x_i = 0$
        \State $x_{i+1} = x_{i+1} + 1$
        \If{$x_{i+1} = 2$}
            \State $p = \Call{Push}{p, i + 1}$
        \EndIf
    \EndIf
    \State \Return $(x, p)$
\EndFunction

\end{algorithmic}
\caption{Incrementa de 1 o contador binário regular~$x$. \label{lst:cnt_reg}}
\end{algorithm}

A função~\func{Add1}{x, p} no Código~\ref{lst:cnt_reg} incrementa de~1 o contador redundante regular~$x$ que tem os índices de seus dígitos~2 armazenados em~$p$.

\section{Visão geral}

Como discutido na Subseção~\ref{subsec:contbin_simples}, a implementação de deque apresentada no Capítulo~\ref{cap:deque2_persist} tem uma certa relação com contadores binários. Iremos então usar a ideia de contadores binários redundantes, discutida na Subseção~\ref{subsec:contbin_redun}, para modificar a implementação da deque persistente para que qualquer operação da deque, exceto~\textsc{k-th}, consuma tempo~$\Oh(1)$.

A representação se mantém parecida. Cada nível contém um prefixo e um sufixo da deque, com o nível~$i+1$ armazenando pares de elementos do nível~$i$. Os prefixos e sufixos, porém, são deques efêmeras que armazenam de zero a cinco elementos. Chamamos estas deques efêmeras de~\deff{sub-deques}. Na Figura~\ref{fig:deque3_ex}, a sub-deque de sufixo do nível~2 tem os pares~$(8, 9)$ e~$(9, 10)$.

\tikzset{drawnode1/.style={row 1 column #1/.style={nodes={draw}}}}
\tikzset{drawnode2/.style={row 2 column #1/.style={nodes={draw}}}}
\tikzset{drawnode3/.style={row 3 column #1/.style={nodes={draw}}}}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw=none, text centered, text width=2em, minimum height=3.1ex, font=\small, align=center, anchor=center}, nodes in empty cells, row sep=2cm},
drawnode1/.list={1, 2, 3, 4, 5, 7, 9, 10, 11, 12, 13},
drawnode2/.list={1, 2, 3, 4, 5, 7, 9, 10, 11, 12, 13},
drawnode3/.list={1, 2, 3, 4, 5, 7, 9, 10, 11, 12, 13},
row 2/.style={nodes={minimum height=6ex}},
row 3/.style={nodes={minimum height=10.7ex}},
]

\matrix[array] (array) {
0 & 1 &  &   &          & &     & &  &  &  & & \\
{2 \\ 3} & & & & &  & &      & {8 \\ 9} & {9 \\ 10} & & & \\
{4 \\ 5 \\ 6 \\ 7} & & & & &  & &      & & & & & \\
 };
 
\draw[dashed] (array-1-7.south west) -- (array-2-1.north west);
\draw[dashed] (array-1-7.south east) -- (array-2-13.north east);
\draw[dashed] (array-2-7.south west) -- (array-3-1.north west);
\draw[dashed] (array-2-7.south east) -- (array-3-13.north east);

%\draw (root.south west) edge (root.north east);
\newcommand{\dnull}[1] { \path[draw] (#1.south west) -- (#1.north east); }

\foreach \p in {1-3, 1-4, 1-5, 1-9, 1-10, 1-11, 1-12, 1-13, 2-2, 2-3, 2-4, 2-5, 2-11, 2-12, 2-13, 3-2, 3-3, 3-4, 3-5, 3-9, 3-10, 3-11, 3-12, 3-13, 3-7} {\dnull{array-\p}}

% \path[draw] (array-2-17.south west) -- (array-2-17.north east);
% \path[draw] (array-3-2.south west) -- (array-3-3.north east);
% \path[draw] (array-4-9.south west) -- (array-4-9.north east);
% \path[draw] (array-4-11.south west) -- (array-4-14.north east);
 
 \node[left= 3pt of array-1-1, xshift=-.2cm]{\small Nível 1: Dígito~2};
 \node[left= 3pt of array-2-1, xshift=-.2cm]{\small Nível 2: Dígito~1};
 \node[left= 3pt of array-3-1, xshift=-.2cm]{\small Nível 3: Dígito~1};

 \node[above=of array-1-3]{$\V{prefix}$};
 \node[above=of array-1-7]{$\V{center}$};
 \node[above=of array-1-11]{$\V{suffix}$};



 \node[above = 3pt of array-1-3]{Dígito~0};
 \node[above = 3pt of array-1-11]{Dígito~2};

 \node[above = 3pt of array-2-3]{Dígito~1};
 \node[above = 3pt of array-2-11]{Dígito~0};

 \node[above = 3pt of array-3-3]{Dígito~1};
 \node[above = 3pt of array-3-11]{Dígito~2};
 
\end{tikzpicture}
\caption{Deque persistente que armazena a sequência~$(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)$.} \label{fig:deque3_ex}
\end{figure}

Cada nível será associado a um dígito~0,~1 ou~2, assim como em um contador binário redundante. Durante o algoritmo, o contador formado pelos dígitos associados a cada nível é regular, considerando que o primeiro nível é o dígito menos significativo. Para garantir isso, usamos uma adaptação do procedimento~\textsc{Fix} discutida anteriormente. Note que o valor do contador não tem relação nenhuma com a estrutura. Apenas usamos sua regularidade para conseguir aplicar todas as operações em tempo constante. Como veremos, a adaptação do procedimento~\textsc{Fix} pode até mudar o valor do contador, diferente da implementação do Código~\ref{lst:cnt_reg}. A deque da Figura~\ref{fig:deque3_ex} é associada ao contador com valor~$112$.

Para cada nível, associamos suas sub-deques (prefixo e sufixo) a algum dígito. O dígito associado ao nível é então o máximo entre estes dois dígitos. O dígito de uma sub-deque é~0 se essa tem dois ou três elementos,~1 se tem um ou quatro elementos, e~2 se tem zero ou cinco elementos. Intuitivamente, esses dígitos estão associados a quanto ``espaço livre'' uma sub-deque tem, tanto para adicionar quanto para remover elementos. Note que, se o dígito é~2, a sub-deque tem zero ou cinco elementos, então pode não ser possível remover ou adicionar algum elemento. De forma similar, se o dígito é~0, é sempre possível adicionar ou remover até dois elementos desta sub-deque. Como escolhemos o máximo entre os dois dígitos, temos que, se um nível tem dígito pequeno, é possível adicionar ou remover elementos tanto de seu prefixo quanto de seu sufixo. Na Figura~\ref{fig:deque3_ex}, o prefixo do nível~2 tem um elemento, logo tem dígito~1, já seu sufixo tem dois elementos, logo dígito~0. O dígito do nível~2 é então o máximo destes valores~(ou seja,~1), indicando que tanto o prefixo quando o sufixo do nível~2 podem adicionar e remover pelo menos um elemento.

Note que, na Figura~\ref{fig:deque3_ex}, o dígito do nível~3 não é o máximo dos dígitos de suas sub-deques. Isto se dá pois este é o último nível, e desta forma sua sub-deque não vazia é tanto prefixo quando sufixo deste nível. Neste caso específico, a quadrupla~$(4, 5, 6, 7)$ é tanto o primeiro quanto o último elemento do nível~3. Assim como na deque recursiva~(linha~\nref{line:deque2:degenerado} do Código~\ref{lst:deque_acesso}), é necessário tratar de forma especial esse caso. Dizemos então que o dígito do último nível é o dígito de sua sub-deque não vazia~(neste caso,~1). Dizemos que esse caso é~\deff{degenerado}.



\section{Regularidade e operações} \label{sec:reg_op}

Uma deque é \deff{regular} ou \deff{semirregular} quando os dígitos de seus níveis formam um contador regular ou semirregular, respectivamente. Vamos garantir que a deque devolvida por qualquer uma das operações é regular.

Assuma que a deque é regular. Para realizar uma operação de~\API{Push} ou~\API{Pop}, note que, devido à regularidade, o primeiro nível tem dígito~0 ou~1, logo ambas suas sub-deques têm dígito~0 ou~1, e então é possível adicionar ou remover um elemento de qualquer uma dessas sub-deques. Se estamos no caso degenerado, ou seja se a deque tem apenas um nível, também é possível adicionar ou remover um elemento de sua sub-deque não vazia, o que é suficiente nesse caso.
Após adicionar ou remover um elemento, o dígito associado ao primeiro nível pode ser~0,~1 ou~2 (ele pode diminuir, aumentar ou continuar igual). É possível que a deque não seja mais regular, passando a ser apenas semirregular; nesse caso, realizamos um procedimento~\textsc{Fix} no primeiro nível que tem dígito~2. Uma diferença dos contadores binários analisados anteriormente é que realizamos um~\textsc{Fix} apenas quando a estrutura não é mais regular.

Um procedimento~\textsc{Fix} no nível~$i$ com dígito~2 transforma esse dígito em~0 e aumenta em no máximo~1 o dígito do próximo nível. Pela semirregularidade da estrutura, o nível~$i+1$ tem dígito~0 ou~1. Para cada uma das sub-deques do nível~$i$, se esta sub-deque tem pelo menos quatro elementos, removemos dois destes, formamos um par com eles e inserimos esse par na correspondente sub-deque do nível~$i+1$; se a sub-deque tem no máximo um elemento, removemos um par da sub-deque do nível~$i+1$, e inserimos os dois elementos do par na sub-deque em questão. Dessa forma, ao final do~\textsc{Fix}, cada uma das sub-deques do nível~$i$ tem dois ou três elementos, então o dígito do nível~$i$ é~0.

Quando dizemos ``remover'' um elemento de uma sub-deque e ``inserir'' em outra, isto deve ser feito na extremidade correta. Por exemplo, remove-se elementos do \emph{final} do prefixo do nível~$i$ para adicionar um par no \emph{início} do prefixo do nível~$i+1$. O procedimento~\textsc{Fix} foi descrito de forma simples, mas na prática é necessário tratar muitos casos, que serão descritos a seguir. É importante notar que~\textsc{Fix} é o mesmo, não importando se o procedimento que o chamou foi~\API{Push} ou~\API{Pop}. Após um~\textsc{Fix} em uma estrutura semirregular, esta se torna regular, pelos mesmos argumentos discutidos na Seção~\ref{sec:contbin}.

\section{Pilha de pilhas, e implementações funcionais} \label{sec:implfunc}

A partir desta seção, representaremos as deques de forma concisa, já que não nos importa mais especificamente quantos ou quais elementos estão em cada prefixo ou sufixo de cada nível, apenas o dígito de cada nível. A Figura~\ref{fig:deque3_ex2} mostra a deque da Figura~\ref{fig:deque3_ex} em versão concisa, e o restante das representações de deque neste capítulo serão desta forma.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=10pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=5mm, font=\small, color=black!70}},
]

\matrix[array] (array) {
1 & 2 & 3 \\
2 & 1 & 1 \\
};

\foreach \i/\j in {1/2,2/3} {\draw[->, shorten >= 5pt, shorten <= 5pt] (array-2-\i) -- (array-2-\j);}

\end{tikzpicture}
\caption{Representação concisa da deque da Figura~\ref{fig:deque3_ex}: os números sobre as caixas indicam o nível e os números dentro das caixas indicam o dígito do nível. Omitem-se os elementos nessa representação.} \label{fig:deque3_ex2}
\end{figure}

A primeira dificuldade é encontrar (e modificar) o primeiro nível com dígito~2, pois este nível pode estar arbitrariamente fundo na lista de níveis. Para a implementação dos contadores binários redundantes, usamos uma pilha com os índices dos dígitos que eram~2. Aquela implementação, porém, não era persistente, e temos que nos preocupar com isso nesta implementação. Assim como nas estruturas persistentes anteriores, vamos fazer uma implementação funcional.

Uma ideia inicial é manter, além da deque persistente, uma pilha (persistente) de nós com dígitos~2 e, como nas implementações anteriores, sempre que for necessário modificar um campo de um nó, copiar esse nó. Isso, porém, não funciona.

\tikzset{drawnode1/.style={row 1 column #1/.style={nodes={draw}}}}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=10pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=5mm, font=\small, color=black!70}},
drawnode1/.list={4, 7, 9}
]

\matrix[array] (array) {
1 & 2 & 3 & |[dashed]|4 & 5 & 6 & 7 & 8 & 9 \\
|[dashed]|0 & 1 & 1 & 2 & 0 & 1 & 2 & 1 & 2 \\
};

\foreach \i/\j in {1/2,2/3,3/4,4/5,5/6,6/7,7/8,8/9} {\draw[->, shorten >= 5pt, shorten <= 5pt] (array-2-\i) -- (array-2-\j);}

\path[shorten >=10pt,shorten <=10pt, ->] (array-1-4.north) edge[bend left] (array-1-7.north)
(array-1-7.north) edge[bend left] (array-1-9.north);
 
\end{tikzpicture}
\caption{Primeira ideia de representação da deque persistente.} \label{fig:func_ex1}
\end{figure}

Considere a Figura~\ref{fig:func_ex1}. Os nós tracejados são os nós de entrada, ou seja, os nós que armazenamos nesta versão da deque; no caso, o primeiro nível e o topo da pilha de nós com dígito 2. Suponha que uma operação de~\API{Push} ou~\API{Pop} modifique o dígito do primeiro nível para~1, e então seja realizado um procedimento~\textsc{Fix} no primeiro dígito~2, no nível~4, e essa operação transforme esse dígito em~0 e o dígito do nível~5 em~1.

Se copiarmos apenas os nós modificados, a estrutura fica como na Figura~\ref{fig:func_ex1res}, que é inválida. Ao acessar o nível~4 a partir do nível~1 (em, por exemplo, uma operação~\API{k-th}), acessamos na verdade a versão antiga do nível~4 (que tinha dígito~2), em vez da nova versão copiada. Isso acontece pois copiamos um nó que era apontado por algum nó não copiado. No caso, o nó de nível~4 era apontado pelo nó de nível~3, que não foi copiado nem modificado, e portanto ainda aponta para a versão antiga do nível~4. Como não modificamos nenhum vértice, esta estrutura é funcional (e persistente), porém ela está errada, já que a nova versão não representa a deque corretamente.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=10pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=5mm, font=\small, color=black!70}}
]

\matrix (A) [array] {
1 & 2 & 3 & |[draw]|4 & 5 & 6 & |[dashed,draw]|7 & 8 & |[draw]|9 \\
0 & 1 & 1 & 2 & 0 & 1 & 2 & 1 & 2 \\
};

\matrix (B) [yshift=-1.8cm, array, row 1/.append style={nodes={draw=none}}, row 2/.style={nodes={draw=none}}, row sep=4pt] {
1 &  &  & 4 & 5 &  &  &  &  \\
|[dashed,draw]|1 &  &  & |[draw]|0 & |[draw]|1 &  &  &  &  \\};

\foreach \i/\j in {1/2,2/3,3/4,4/5,5/6,6/7,7/8,8/9} {\draw[->, shorten >= 5pt, shorten <= 5pt] (A-2-\i) -- (A-2-\j);}

\path[shorten >=10pt,shorten <=10pt, ->] (A-1-4.north) edge[bend left] (A-1-7.north)
(array-1-7.north) edge[bend left] (array-1-9.north);

\path[shorten >= 5pt, shorten <= 5pt, ->] (B-2-4.east) edge (B-2-5.west)
(B-2-1.east) edge (A-2-2.west) (B-2-5.east) edge (A-2-6.west);
 
\end{tikzpicture}
\caption{Deque inválida gerada depois de uma operação de modificação na deque da Figura~\ref{fig:func_ex1}, seguida de um~\textsc{Fix}.} \label{fig:func_ex1res}
\end{figure}


Para implementar corretamente uma estrutura de forma funcional (e portanto persistente), é necessário copiar todos os nós que precisam ser modificados, e além disso garantir que~\emph{nenhum nó copiado é apontado por um nó não copiado}. Na implementação da deques persistentes do Capítulo~\ref{cap:deque2_persist}, isso é sempre verdade pois copiamos um prefixo dos níveis, e cada nível apenas aponta para o próximo nível, e nas implementações de pilha, fila e deque dos Capítulos~\ref{cap:pilha_persist} e~\ref{cap:deque1_persist}, isto também vale.

Para consertar a implementação, precisamos garantir que os nós copiados não são apontados por nós não copiados. Para isso, separa-se os níveis em várias pilhas; em cada pilha o nível do topo tem dígito diferente de~1, ou é o nível~1, e todos os outros elementos da pilha têm dígito~1. Faz-se então uma pilha em que cada elemento é o topo de uma destas sub-pilhas. Desse modo, o procedimento~\textsc{Fix} é sempre realizado no nível~1 ou no primeiro elemento da segunda pilha, já que ou um deles é o primeiro dígito~2 ou a estrutura já é regular.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=3pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=3mm, font=\footnotesize, color=black!70}}
]

\matrix (A) [array] {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
0 & 1 & 1 & 2 & 0 & 1 & 2 & 1 & 1 \\
};

%\matrix (B) [yshift=-1.8cm, array, row 1/.append style={nodes={draw=none}}, row 2/.style={nodes={draw=none}}, row sep=4pt] {
%1 &  &  & 4 & 5 &  &  &  &  \\
%|[dashed,draw]|1 &  &  & |[draw]|0 & |[draw]|1 &  &  &  &  \\};

\foreach \i/\j in {1/2,2/3,5/6,7/8,8/9} {\draw[->, shorten >= 5pt, shorten <= 5pt] (A-2-\i) -- (A-2-\j);}

\node[draw, fit = (A-2-1) (A-1-1) (A-2-3)] (p1) {};
\node[draw, fit = (A-2-4) (A-1-4) (A-2-4)] (p2) {};
\node[draw, fit = (A-2-5) (A-1-5) (A-2-6)] (p3) {};
\node[draw, fit = (A-2-7) (A-1-7) (A-2-9)] (p4) {};

\foreach \i/\j in {1/2,2/3,3/4} { \draw[->,shorten >= 2pt, shorten <= 2pt, thick] (p\i.east) -- (p\j.west); }

\end{tikzpicture}
\caption{Segunda ideia de representação da deque persistente.} \label{fig:func_ex2}
\end{figure}

A Figura~\ref{fig:func_ex2} mostra como seriam essas pilhas na mesma deque da Figura~\ref{fig:func_ex1}. Faremos a implementação destas pilhas adicionando um campo a cada nó, o campo~$\V{next}$, que, para nós que são topos de pilhas (ou seja, o nó do nível~1 e os nós com dígitos diferentes de~1), armazena o topo da próxima pilha, isto é, o próximo nó com dígito diferente de~1. Para todos os outros nós o campo~$\V{next}$ armazena~\keyword{null}.


\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=3pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=3mm, font=\footnotesize, color=black!70}}
]

\matrix (A) [array] {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
0 & 1 & 1 & 2 & 0 & 1 & 2 & 1 & 1 \\
};

%\matrix (B) [yshift=-1.8cm, array, row 1/.append style={nodes={draw=none}}, row 2/.style={nodes={draw=none}}, row sep=4pt] {
%1 &  &  & 4 & 5 &  &  &  &  \\
%|[dashed,draw]|1 &  &  & |[draw]|0 & |[draw]|1 &  &  &  &  \\};

\foreach \i/\j in {1/2,2/3,5/6,7/8,8/9} {\draw[->, shorten >= 5pt, shorten <= 5pt] (A-2-\i) -- (A-2-\j);}

\foreach \i/\j in {1/4,4/5,5/7} { \path[->,shorten >= 8pt, shorten <= 8pt, dashed] (A-2-\i.south) edge[bend right] (A-2-\j.south); }

\end{tikzpicture}
\caption{Mais detalhes da segunda ideia de representação da deque persistente.} \label{fig:func_ex3}
\end{figure}


A Figura~\ref{fig:func_ex3} mostra como fica a estrutura, baseando-se nessa implementação, onde as flechas tracejadas indicam os ponteiros~$\V{next}$ não nulos. Removemos alguns ponteiros armazenados nos campos~$\V{child}$, mais precisamente os que apontam para a próxima sub-pilha, isso é feito pois a próxima sub-pilha deve ser acessada pelo ponteiro~$\V{next}$ do primeiro elemento da sub-pilha. Dessa forma, não é mais possível acessar nós de versões passadas. Com isso, a navegação pelos níveis fica um pouco mais complexa, já que um nó pode ter o campo~$\V{child}$ nulo e ainda assim existir um nó no próximo nível. A Figura~\ref{fig:func_ex3res} mostra a estrutura após as mesmas modificações que foram aplicadas na Figura~\ref{fig:func_ex1res}. Note que agora cada deque pode ser armazenada apenas com um ponteiro para o seu primeiro nível, já que não é mais necessário armazenar o ponteiro para a pilha separadamente.


\begin{figure}[h]
\centering
\begin{tikzpicture}[
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, anchor=center}, nodes in empty cells, row sep=3pt, column sep = 30pt},
row 1/.style={nodes={draw=none, minimum size=3mm, font=\footnotesize, color=black!70}}
]

\matrix (A) [array] {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
0 & 1 & 1 & 2 & 0 & 1 & 2 & 1 & 1 \\
};

\matrix (B) [yshift=-2.3cm, array, row 1/.append style={nodes={draw=none}}, row 2/.style={nodes={draw=none}}, row sep=3pt] {
1 &  &  & 4 & 5 &  &  &  &  \\
|[draw]|1 &  &  & |[draw]|0 & |[draw]|1 &  &  &  &  \\};

\foreach \i/\j in {1/2,2/3,5/6,7/8,8/9} {\draw[->, shorten >= 5pt, shorten <= 5pt] (A-2-\i) -- (A-2-\j);}

\path[->, shorten >= 5pt, shorten <= 5pt] (B-2-1.east) edge (A-2-2.south) (B-2-4) edge (B-2-5) (B-2-5.east) edge (A-2-6.south);

\path[->, shorten >= 8pt, shorten <= 8pt, dashed] (B-2-1.south) edge[bend right] (B-2-4.south)
(B-2-4.south) edge[out = -30, in=-90] (A-2-7.south);

\foreach \i/\j in {1/4,4/5,5/7} { \path[->,shorten >= 8pt, shorten <= 8pt, dashed] (A-2-\i.south) edge[bend right] (A-2-\j.south); }

\end{tikzpicture}
\caption{Deque da Figura~\ref{fig:func_ex3} após uma operação de modificação seguida de um~\textsc{Fix}.} \label{fig:func_ex3res}
\end{figure}

\section{Representação}

A representação de um nível da deque será similar à do Capítulo~\ref{cap:deque2_persist}. Um nível da deque é representado por um nó~$u$, que terá os campos~$\V{prefix}$,~$\V{suffix}$,~$\V{child}$ e~$\V{next}$.
Os campos~$\V{prefix}$ e~$\V{suffix}$, como anteriormente, guardam um prefixo e um sufixo da deque representada por~$u$, mas agora estes campos são deques efêmeras de tamanho até cinco. Chamamos estas deques efêmeras de cada nível de~\deff{sub-deques}. Consideramos que~$\{\}$ cria uma deque efêmera vazia, e que cada deque tem funções homônimas às descritas no início do Capítulo~\ref{cap:deque1_persist}, mas não recebem a deque e não devolvem uma nova deque. Além disso, as operações~\textsc{Pop} devolvem o valor removido, e a função~\func{Size}{} devolve o número de elementos na deque efêmera. Por exemplo, se~$d$ é uma deque efêmera,~$d.\func{PopBack}{}$ remove o último elemento de~$d$ e o devolve, modificando~$d$.

Como discutido na seção anterior, o campo~$\V{next}$ de~$u$ aponta para o próximo nível com dígito diferente de~1, se tal nível existir e se~$u$ não tiver dígito~1, ou se~$u$ for o primeiro nível. O campo~$\V{child}$ do nó~$u$ aponta para o nó do próximo nível, se tal nível existir e tiver dígito~1.

\section{Procedimento~{\normalfont \textsc{Fix}} detalhado} \label{sec:fix_det}

Vamos analisar mais detalhadamente os casos possíveis para o procedimento~\textsc{Fix}. Ao aplicar o~\textsc{Fix} em um nó de nível~$i$ com dígito~2, queremos transformar esse dígito em~0, possivelmente modificando o nível~$i+1$. Pela semirregularidade temos que o dígito do nível~${i+1}$ não é~2. A necessidade de tratar múltiplos casos se deve ao caso degenerado.

Para reduzir a descrição dos casos, vamos utilizar uma função auxiliar~\func{FixDeques}{l,r,L,R}. Essa função recebe duas sub-deques efêmeras~$l$ e~$r$, o prefixo e sufixo do~nível~$i$ da deque que estamos realizando o procedimento~\textsc{Fix} e deixa ambas com dois ou três elementos, possivelmente modificando as sub-deques~$L$ e~$R$, o prefixo e sufixo do nível~${i+1}$, tornando este nível vazio ou aumentando em no máximo~1 seu dígito. Este procedimento só funciona se existem mais de três elementos de nível~$i$ entre todas as deques da chamada, isto é, se~${\Call{Size}{l} + \Call{Size}{r} + 2\,\Call{Size}{L} + 2\,\Call{Size}{R} > 3}$.

Para aplicar um procedimento~\textsc{Fix}, devemos primeiramente criar um nível~$i+1$ vazio se este não existir. Após isso, considera-se os seguintes casos:

\begin{description}
    \item[Caso 1.] Existem no máximo três elementos de nível~$i$ entre os níveis~$i$ e~$i+1$. \\ Adicione todos os elementos dos níveis~$i$ e~${i+1}$ no prefixo do nível~$i$, mantendo a ordem, e remova o nível~$i+1$.
    \item[Caso 2.] Existem mais do que três elementos de nível~$i$ entre os níveis~$i$ e~${i+1}$. \\ Sejam~$a$ e~$b$ os nós que representam os níveis~$i$ e~${i+1}$, respectivamente; execute a função~\func{FixDeques}{a.\V{prefix}, a.\V{suffix}, b.\V{prefix}, b.\V{suffix}}. Se o nível~$i+1$ é agora o último nível e está vazio, remova-o.
\end{description}

Assumindo que a função~\textsc{FixDeques} funciona, os casos tratam corretamente o~\textsc{Fix}. No Caso~1, não existe nível~${i+2}$, pois o nível~${i+1}$ não tem mais que um elemento, então se não fosse o último nível, teria dígito~2, uma contradição pela semirregularidade da estrutura.

Além disso, o prefixo do nível~$i$ vai ter, ao final da função, dois ou três elementos. De fato, é impossível que exista apenas um elemento de nível~$i$ entre os níveis~$i$ e~$i+1$, pois isso implicaria que não existem elementos em~$i+1$, e o nível~$i+1$ teria dígito~2 (uma contradição pela semirregularidade da estrutura), ou que o nível~${i+1}$ não existe, e então o nível~$i$ é o último e tem exatamente um elemento. Mas nesse caso o dígito desse nível não é~2.

Ainda resta, no procedimento~\textsc{Fix}, arrumar os campos~$\V{child}$ e~$\V{next}$ dos nós modificados, que podem ter mudado. Essas dificuldades serão tratadas na descrição da implementação, discutida nas próximas seções.

\section{Implementação de {\normalfont \textsc{FixDeques}}} \label{sec:fix_deques}

O Código~\ref{lst:fix_deques} apresenta a implementação da função~\func{FixDeques}{l, r, L, R}, onde~$l$ e~$r$ são o prefixo e sufixo do nível~$i$ de dígito~2, e~$L$ e~$R$ são o prefixo e sufixo do nível~$i+1$ de dígito~0 ou~1. É possível que o nível~$i+1$ não exista na deque atual; nesse caso~$L$ e~$R$ são deques efêmeras vazias.

\begin{algorithm}
\begin{algorithmic}[1]

\Require $l.\Call{Size}{\null} + r.\Call{Size}{\null} + 2\cdot L.\Call{Size}{\null} + 2\cdot R.\Call{Size}{\null} > 3$
\Function{FixDeques}{$l, r, L, R$}
    \If{${l}.\Call{Size}{\null} \geq 4$} \label{line:fd:if5}
        \State $b = {l}.\Call{PopBack}{\null}$
        \State $a = {l}.\Call{PopBack}{\null}$
        \State ${L}.\Call{PushFront}{(a, b)}$
    \EndIf
    \If{${r}.\Call{Size}{\null} \geq 4$} \label{line:fd:if6}
        \State $a = {r}.\Call{PopFront}{\null}$
        \State $b = {r}.\Call{PopFront}{\null}$
        \State ${R}.\Call{PushBack}{(a, b)}$
    \EndIf
    \If{${l}.\Call{Size}{\null} \leq 1$} \label{line:fd:if3}
        \If{${L}.\Call{Size}{\null} \neq 0$} \label{line:fd:if1}
            \State $(a, b) = {L}.\Call{PopFront}{\null}$
        \Else
            \State $(a, b) = {R}.\Call{PopFront}{\null}$
        \EndIf
        \State ${l}.\Call{PushBack}{a}$
        \State ${l}.\Call{PushBack}{b}$
    \EndIf
    \If{${r}.\Call{Size}{\null} \leq 1$} \label{line:fd:if4}
        \If{${R}.\Call{Size}{\null} \neq 0$} \label{line:fd:if2}
            \State $(a, b) = {R}.\Call{PopBack}{\null}$
        \Else
            \State $(a, b) = {L}.\Call{PopBack}{\null}$
        \EndIf
        \State ${r}.\Call{PushFront}{b}$
        \State ${r}.\Call{PushFront}{a}$
    \EndIf
\EndFunction

\end{algorithmic}
\caption{Função~\textsc{FixDeques}} \label{lst:fix_deques}
\end{algorithm}

A função, para cada sub-deque, se esta tem pelo menos quatro elementos, remove dois destes e os insere na sub-deque correspondente do nível~$i+1$. Se a sub-deque tem no máximo um elemento, então um par é removido da sub-deque correspondente do nível~$i+1$ e os dois elementos do par são adicionados na sub-deque. Dessa forma, ao final do procedimento, ambas as sub-deques têm dois ou três elementos, e o dígito do nível~$i$ se torna~0. Também mostraremos que o dígito do nível~$i+1$ aumenta em no máximo~1, se esse nível não for o último e estiver vazio.

Os~\keyword{if}s das linhas~\nref{line:fd:if5} e~\nref{line:fd:if6} do Código~\ref{lst:fix_deques} tratam os casos de remover elementos do nível~$i$ para adicioná-los ao nível~${i+1}$, e os~\keyword{if}s das linhas~\nref{line:fd:if3} e~\nref{line:fd:if4} tratam os casos de remover um par do nível~$i+1$ e adicionar seus elementos ao nível~$i$. Se alguma das sub-deques do nível~$i+1$ está vazia, então este é o último nível (ou então teria dígito~2, uma contradição). Logo, a sub-deque não vazia é o prefixo e sufixo deste nível. Assim os~\keyword{if}s das linhas~\nref{line:fd:if1} e~\nref{line:fd:if2} tratam corretamente esse caso. Dessa forma, o código faz como descrevemos, resta provar que as operações nas sub-deques~$L$ e~$R$ são sempre válidas, ou seja, nunca é executada uma operação de~\textsc{Push} em uma sub-deque cheia ou uma operação de~\textsc{Pop} quando o nível~$i+1$ está vazio.

As deques~$L$ e~$R$ não têm cinco elementos pois, se tivessem, o dígito do nível~$i+1$ seria~2, não importando se este é o último nível ou não. Isso implica que as chamadas de \textsc{Push} nos~\keyword{if}s das linhas~\nref{line:fd:if5} e~\nref{line:fd:if6} sempre funcionam. Além disso, no máximo um entre os~\keyword{if}s das linhas~\nref{line:fd:if5} e~\nref{line:fd:if3} é executado, assim como entre os~\keyword{if}s das linhas~\nref{line:fd:if6} e~\nref{line:fd:if4}. Dessa forma, se algum dos primeiros dois~\keyword{if}s é executado, pela ordem que as operações são feitas, temos que o nível~$i+1$ não está vazio e no máximo um dos últimos dois~\keyword{if}s também é executado. Logo as operações de~\textsc{Pop} não serão executadas com o nível~$i+1$ vazio nesse caso.

Os únicos casos em que uma operação de~\textsc{Pop} pode ser inválida são:
\begin{itemize}
    \item Os últimos dois~\keyword{if}s são executados, ou seja, se~$l$ e~$r$ têm no máximo um elemento; e o nível~$i+1$ tem no máximo um par. Como a função~\textsc{FixDeques} só é chamada se existem mais que três elementos de nível~$i$ entre todas as sub-deques, o único caso que isso pode acontecer é quando as deques~$l$ e~$r$ têm exatamente um elemento, e existe exatamente um par em uma das deques~$L$ ou~$R$. Mas nesse caso o dígito do nível~$i$ seria~1, e~\textsc{FixDeques} não seria chamada.
    \item Apenas um dos últimos dois~\keyword{if}s é executado, e o nível~$i+1$ está vazio, ou seja, o nível~$i$ é o último. Isso ocorre se uma entre~$l$ e~$r$ tem dois ou três elementos, e a outra tem no máximo um. Mas este caso não ocorre pois o dígito do nível~$i$ seria~1, e~\textsc{FixDeques} não seria chamada.
\end{itemize}

Logo, não existe situação em que a execução da função~\textsc{FixDeques} faz chamadas de~\textsc{Push} ou~\textsc{Pop} inválidas, e portanto o~Código~\ref{lst:fix_deques} funciona corretamente.

\section{Implementação de {\normalfont \textsc{Fix}}}

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Digit}{$a, \V{last}$}
    \State $\V{digit} = [2, 1, 0, 0, 1, 2]$ \Comment{$\V{digit}[i + 1] = $ dígito de uma sub-deque com~$i$ elementos}
    \If{$a.\V{prefix}.\Call{Size}{\null} = 0 \AND \V{last}$}
        \State \Return $\V{digit}[a.\V{suffix}.\Call{Size}{\null} + 1]$
    \ElsIf{$a.\V{suffix}.\Call{Size}{\null} = 0 \AND \V{last}$}
        \State \Return $\V{digit}[a.\V{prefix}.\Call{Size}{\null} + 1]$
    \Else
        \State \Return $\max(\V{digit}[a.\V{prefix}.\Call{Size}{\null} + 1], \V{digit}[a.\V{suffix}.\Call{Size}{\null} + 1])$
    \EndIf
\EndFunction

\Require $a$ é de nível~$i$, o primeiro nó com dígito~2.
\Function{Fix}{$a$}
    \If{$a.\V{child} \neq \Null$} \label{line:fix:p1b}
        \State $b = \Call{Copy}{a.\V{child}}$
        \State $\V{last} = [a.\V{next} = \Null \AND b.\V{child} = \Null]$
    \ElsIf{$a.\V{next} \neq \Null$}
        \State $b = \Call{Copy}{a.\V{next}}$
        \State $\V{last} = [b.\V{next} = \Null \AND b.\V{child} = \Null]$
    \Else
        \State $b = \New \Call{Node}{\{\}, \Null, \{\}}$
        \State $last = \True$ \label{line:fix:p1e}
    \EndIf

    \If{$a.\V{prefix}.\Call{Size}{\null} + a.\V{suffix}.\Call{Size}{\null} + 2\,b.\V{prefix}.\Call{Size}{\null} + 2\,b.\V{suffix}.\Call{Size}{\null} \leq 3$} \Comment{Caso 1}  \label{line:fix:p2b}
        \If{$b.\V{prefix}.\Call{Size}{\null} \neq 0$}
            \State $(x, y) = b.\V{prefix}.\Call{PopFront}{\null}$
            \State $a.\V{prefix}.\textsc{PushBack}(x)$
            \State $a.\V{prefix}.\textsc{PushBack}(y)$
        \EndIf
        \If{$b.\V{suffix}.\Call{Size}{\null} \neq 0$}
            \State $(x, y) = b.\V{suffix}.\Call{PopFront}{\null}$
            \State $a.\V{prefix}.\textsc{PushBack}(x)$
            \State $a.\V{prefix}.\textsc{PushBack}(y)$
        \EndIf
        \If{$a.\V{suffix}.\Call{Size}{\null} \neq 0$}
            \State $a.\V{prefix}.\textsc{PushBack}(a.\V{suffix}.\Call{PopFront}{\null})$
        \EndIf
        \State $b = \Null$  \label{line:fix:p2e}
    \Else \Comment{Caso 2}  \label{line:fix:p3b}
        \State $\Call{FixDeques}{a.\V{prefix}, a.\V{suffix}, b.\V{prefix}, b.\V{suffix}}$
        \If{${b.\V{prefix}}.\Call{Size}{\null} = 0 \AND {b.\V{suffix}}.\Call{Size}{\null} = 0 \AND \V{last}$} \label{line:fix:if_empty}
            \State $b = \Null$  \label{line:fix:p3e}
        \EndIf
    \EndIf

    \If{$b \neq \Null \AND \Call{Digit}{b, \V{last}} = 1$}
        \If{$a.\V{child} = \Null$} \Comment{Nível $i + 1$ tinha dígito diferente de~1.} \label{line:fix:next_a_bb}
            \State $a.\V{next} = b.\V{next}$
            \State $b.\V{next} = \Null$ \label{line:fix:next_a_be}
        \EndIf
        \State $a.\V{child} = b$ \label{line:fix:child_a_b}
    \Else
        \If{$b \neq \Null \AND a.\V{child} \neq \Null$} \label{line:fix:next_b_ab}
            \State $b.\V{next} = a.\V{next}$  \label{line:fix:next_b_ae}
        \EndIf
        \State $a.\V{next} = b$ \label{line:fix:child_b_ab}
        \State $a.\V{child} = \Null$  \label{line:fix:child_b_ae}
    \EndIf
\EndFunction

\end{algorithmic}
\caption{Operação~\textsc{Fix}.} \label{lst:op_fix}
\end{algorithm}

O Código~\ref{lst:op_fix} apresenta a implementação de~\func{Fix}{a}, uma função que recebe um nó de nível~$i$ com dígito~2 e faz alterações nele para transformar seu dígito em~0, aumentando em até~1 o dígito do nível~$i+1$. O nó~$a$ é modificado, mas uma cópia do nível~$i+1$ é feita. Assim não modificamos o nó original de nível~$i+1$. Para não modificar um nó da estrutura, quando usarmos esta função na implementação das operações da deque em seções futuras, chamaremos a função com uma cópia do nó de nível~$i$. Usamos a função~\func{Copy}{x} para devolver uma cópia de um nó~$x$, em tempo constante. Se~$x$ for~\keyword{null}, essa função devolve um nó vazio (com as sub-deques vazias e os campos nulos).

A função~\func{Digit}{a, \V{last}} devolve o dígito do nó~$a$, onde~$\V{last}$ é~\textbf{true} se não existe nível depois de~$a$, e~\textbf{false} caso contrário. O parâmetro~$\V{last}$ é necessário pois um nó pode ter o campo~$\V{child}$ nulo, mas ainda assim existir um nó no próximo nível. Nesse caso, o nó de próximo nível é o campo~$\V{next}$ da cabeça da sub-pilha que contém~$a$. Veja a Figura~\ref{fig:func_ex3}, onde o nó de nível~3 tem campo~$\V{child}$ nulo, mas existe nó de nível~4, e um ponteiro para este está armazenado apenas no nó de nível~1.

As linhas~{\nref{line:fix:p1b}-\nref{line:fix:p1e}} copiam o nó de nível~$i+1$ na variável~$b$, criando um nó vazio se este não existir. Se o nó de nível~${i+1}$ existir, ele pode estar tanto no campo~$\V{child}$, se tiver dígito~1, quanto no campo~$\V{next}$, se tiver dígito~0.
Também é armazenado na variável~$\V{last}$ o valor~\textbf{true} se não existe nível~$i+2$, e~\textbf{false} caso contrário. A notação~$[$\texttt{predicado}$]$ de Iverson devolve~\textbf{true} (ou~1) se~\texttt{predicado} é verdade e~\textbf{false} (ou~0) se é falso.

As linhas~{\nref{line:fix:p2b}-\nref{line:fix:p2e}} resolvem o Caso~1, como discutido na Seção~\ref{sec:fix_det}, adicionando todos elementos das sub-deques dos níveis~$i$ e~$i+1$ no prefixo do nó~$a$, e apagando~$b$. Usamos o fato que cada sub-deque em ambos os níveis tem no máximo um elemento.

O Caso~2 é tratado nas linhas~{\nref{line:fix:p3b}-\nref{line:fix:p3e}}. Na Seção~\ref{sec:fix_deques} argumentamos que a função~\textsc{FixDeques} está correta. O~\keyword{if} da linha~\nref{line:fix:if_empty} verifica se não existe nível~$i+2$ e ambas as sub-deques do nível~$i+1$ estão vazias. Nesse caso o nível~$i+1$ é removido.

Portanto, os casos são tratados corretamente. As linhas seguintes arrumam os campos~$\V{child}$ e~$\V{next}$ de~$a$ e~$b$. Se~$b$ existe e tem dígito~1, este deve ser armazenado no campo~$\V{child}$ de~$a$ (linha~\nref{line:fix:child_a_b}). Se o nível~$i+1$ tinha dígito diferente de~1 (esse dígito era~0 pela semirregularidade da estrutura), então esse nível era o~$\V{next}$ de~$a$, e precisamos mudar o ponteiro~$\V{next}$ de~$a$ para ser o próximo nível com dígito diferente de~1 (linhas~\nref{line:fix:next_a_bb}-\nref{line:fix:next_a_be}). Usamos que se~$b$ tinha dígito diferente de~1, então~$a.\V{child}$ era nulo.

Se~$b$ não tem dígito~1, ou não existe, deve ser armazenado no campo~$\V{next}$ de~$a$ (linhas~\nref{line:fix:child_b_ab}-\nref{line:fix:child_b_ae}).
Se~$b$ tinha dígito~1 no início da operação, e ainda existe, é necessário guardar o valor antigo de~$a.\V{next}$ em~$b.\V{next}$ (linhas~\nref{line:fix:next_b_ab}-\nref{line:fix:next_b_ae}). Caso contrário, o campo~$b.\V{next}$ permanece o mesmo, pois já apontava para o próximo nível com dígito diferente de~1.

Note que é conveniente armazenar o próximo dígito diferente de~1, e não apenas o próximo dígito~2, pois assim ao final do~\textsc{Fix} temos garantia que~$a$ continua sendo topo de uma sub-pilha, já que tem dígito~0.

\section{Implementação das operações}

Com a função~\textsc{Fix} implementada, é fácil implementar as operações da deque com consumo de tempo constante. Tendo em vista a regularidade da estrutura, é sempre possível realizar um~\API{Push} ou~\API{Pop} no primeiro nível e, após isto basta chamar a função~\textsc{Fix} no nó adequado, como discutido na Seção~\ref{sec:reg_op}.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Check}{$a$}
    \If{$\Call{Digit}{a, [a.\V{child} = \Null \AND a.\V{next} = \Null]} = 2$}
        \State $\Call{Fix}{a}$
    \ElsIf{$a.\V{next} {\,\neq\,} \Null \AND \Call{Digit}{a.\V{next}, [a.\V{next}.\V{child} {\,=\,} \Null \AND a.\V{next}.\V{next} {\,=\,} \Null]} = 2$}
        \State $a.\V{next} = \Call{Copy}{a.\V{next}}$
        \State $\Call{Fix}{a.\V{next}}$
    \EndIf
\EndFunction

\Function{\API{PushFront}}{$a, x$}
    \State $a = \Call{Copy}{a}$
    \State $a.\V{prefix}.\Call{PushFront}{x}$
    \State $\Call{Check}{a}$
    \State \Return $a$
\EndFunction

\Function{\API{PopFront}}{$a$}
    \State $a = \Call{Copy}{a}$
    \If{$a.\V{prefix}.\Call{Size}{\null} \neq 0$}
        \State $a.\V{prefix}.\Call{PopFront}{\null}$
    \Else
        \State $a.\V{suffix}.\Call{PopFront}{\null}$
    \EndIf
    \State $\Call{Check}{a}$
    \State \Return $a$
\EndFunction

\Function{\API{Front}}{$a$}
    \If{$a.\V{prefix}.\Call{Size}{\null} \neq 0$}
        \State \Return $a.\V{prefix}.\Call{Front}{\null}$
    \Else
        \State \Return $a.\V{suffix}.\Call{Front}{\null}$
    \EndIf
\EndFunction

\end{algorithmic}
\caption{Operações da deque} \label{lst:ops_deque_const}
\end{algorithm}

O Código~\ref{lst:ops_deque_const} mostra as implementações das versões~\textsc{Front} das operações da deque. A função~\func{Check}{a} realiza um~\textsc{Fix} na deque com topo~$a$, se necessário, ou seja, se esta não é regular. Logo, após essa operação, é garantido que a estrutura é regular, como discutido na Seção~\ref{sec:reg_op}.

Note que as operações~\API{PushFront} e~\API{PopFront} copiam o topo da deque, e a função~\textsc{Check} copia o campo~$\V{next}$ deste elemento se for necessário modificá-lo. A função~\func{Fix}{a} modifica~$a$, mas está na verdade recebendo uma cópia do nó. Como a implementação é feita de acordo com a discussão na Seção~\ref{sec:implfunc}, garantimos que todo nó copiado é apenas apontado por outros nós copiados, e assim a implementação é funcional, e portanto persistente.

\begin{table} \centering
\begin{tabular}{|l|c|}
	\hline
	Operação & Tempo/Espaço \\ \hline
	\funcAPI{Deque}{} & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PushFront}{q, x} & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PushBack}{q, x} & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Front}{q} & $\Oh(1)$ \\
	\funcAPI{Back}{q} & $\Oh(1)$ \\
	\funcAPI{PopFront}{q} & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PopBack}{q} & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{k-th}{q, k} & $\Oh(\lg n)$ \\ \hline
\end{tabular}
	\caption{Consumo de tempo e espaço da implementação deste capítulo, onde~$n$ é o tamanho da estrutura da deque persistente. \label{tab:deque3_persist}}
\end{table}

Os~\keyword{if}s das operações~\API{PopFront} e~\API{Front} checam os casos degenerados, já que, como a estrutura é regular, se uma das sub-deques de~$a$ é vazia então~$a$ é tanto o topo quanto o último nível da estrutura.

A operação~\funcAPI{k-th}{d, k} não foi implementada, mas pode ser feita de forma um pouco mais complexa porém similar ao Código~\ref{lst:deque_kth}. A Tabela~\ref{tab:deque3_persist} mostra o consumo de tempo e espaço da implementação discutida neste capítulo. Note que a operação~\API{k-th} consome temporariamente espaço~$\Oh(\lg n)$ devido a sua pilha de recursão. A Tabela~\ref{tab:deque_persist_comp} compara o consumo de tempo e espaço de todas as deques persistentes apresentadas neste trabalho.

\begin{table} \centering
\begin{tabular}{|l|c|c|c|c|}
	\hline
	Operação & Representação binária & Skew-binary & Recursiva & Kaplan e Tarjan  \\ \hline
	\funcAPI{Deque}{} & $\Oh(1) / \Oh(1)$ & $\Oh(1) / \Oh(1)$ & $\Oh(1) / \Oh(1)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PushFront}{q, x} & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PushBack}{q, x} & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Front}{q} & $\Oh(1)$ & $\Oh(1)$ & $\Oh(\lg n)$ & $\Oh(1)$ \\
	\funcAPI{Back}{q} & $\Oh(1)$ & $\Oh(1)$ & $\Oh(\lg n)$ & $\Oh(1)$ \\
	\funcAPI{PopFront}{q} & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{PopBack}{q}  & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{k-th}{q, k} & $\Oh(\lg n)$ & $\Oh(\lg n)$ & $\Oh(\lg n)$ & $\Oh(\lg n)$ \\ \hline
\end{tabular}
	\caption{Comparação do consumo de tempo e espaço das implementações das deques descritas nos Capítulos~\ref{cap:deque1_persist},~\ref{cap:deque2_persist} e~\ref{cap:deque3_persist}, onde~$n$ é o tamanho da estrutura da deque persistente. \label{tab:deque_persist_comp}}
\end{table}

\end{document}
