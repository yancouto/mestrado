\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Técnicas gerais} \label{cap:geral_persist}

Nos capítulos anteriores, discutimos como tornar persistentes estruturas de dados específicas (pilhas, filas, deques). Como dito na introdução, outro caminho é criar técnicas gerais para tornar qualquer ED persistente.


\section{Modelo de computação}

Para tomar uma abordagem tão geral, é necessário definir formalmente o conceito de estrutura de dados.  Usaremos o modelo de~\deff{estruturas ligadas}, no qual uma estrutura de dados é um conjunto de \emph{nós}, ou \emph{objetos}, cada um contendo um número constante de campos. Cada campo pode armazenar um valor (um inteiro ou booleano, por exemplo) ou um ponteiro para outro nó. Ponteiros também podem armazenar o valor especial~\keyword{null}.  Acesso à estrutura é dado por um número constante de~\deff{nós de entrada}.

% XXX Preciso assumir que todos os nós são do mesmo tipo?

Uma pilha implementada com lista ligada, como no Capítulo~\ref{cap:pilha_persist}, é uma estrutura desse tipo, onde o primeiro elemento da lista é o nó de entrada. A estrutura recursiva para deques do Capítulo~\ref{cap:deque2_persist} também é dessa forma, e tem nós de dois tipos: os nós da estrutura e nós que são os pares. O nó de entrada também é o primeiro nó da estrutura.  Uma árvore de busca binária também é deste tipo, já que cada nó tem dois ponteiros (para o filho esquerdo e direito), e um valor; e a raiz é o nó de entrada.  A estrutura para deque do Capítulo~\ref{cap:deque1_persist} não é deste tipo, pois o preprocessamento para o LA armazena em cada nó um vetor de tamanho~$\floor{\lg d}$, onde~$d$ é a altura do nó.

Vamos formalizar também as definições de operações de acesso e modificação. Uma~\deff{operação de acesso} produz um~\deff{conjunto de acessos}. No início da operação, este conjunto está vazio.  A cada passo, chamado de~\deff{passo de acesso}, adiciona-se um nó a este conjunto. O nó adicionado deve ser um nó de entrada ou deve ser indicado por um ponteiro em algum nó já no conjunto de acessos. O tempo consumido por uma operação de acesso é o número de passos de acesso. Operações também retornam valores, calculados usando seu conjunto de acessos.

A busca em uma ABB por um elemento é um exemplo de operação de acesso, que retorna se o elemento está ou não na ABB. Um exemplo mais complicado é a operação~\textsc{k-th} da deque recursiva, que primeiro encontra o nó da estrutura em que se localiza o $k$-ésimo elemento, e depois ``descasca'' os pares para encontrar e retornar este elemento.

Uma~\deff{operação de modificação} é parecida com uma de acesso. Ela consiste de passos de acesso, que funcionam da mesma forma, e~\deff{passos de modificação}. Em um passo de modificação, uma das seguintes operações é feita:
\begin{itemize}
	\item Cria-se um novo nó, e este é adicionado ao conjunto de acessos.
	\item Modifica-se um campo de algum nó do conjunto de acessos. Se um ponteiro foi modificado, seu novo valor deve ser~\keyword{null} ou deve ser um dos nós do conjunto de acessos.
	\item Troca-se um nó de entrada. Seu novo valor deve ser~\keyword{null} ou um nó do conjunto de acessos.
\end{itemize}

O tempo consumido por esta operação de modificação é o número total de passos, e o tempo de modificação é o número de passos de modificação.

Adicionar um elemento em uma ABB, por exemplo, consiste de achar sua posição, que pode levar até~$h$ passos de acesso, onde~$h$ é a altura da árvore, e criar um novo vértice ali, modificando um dos ponteiros desse nó. Logo esta operação consome tempo~$\Oh(h)$ e tempo de modificação~$\Oh(1)$.

Essas definições descrevem uma estrutura de dados efêmera, ou seja, uma ED na qual operações de acesso e modificação podem apenas ser feitas na versão mais atual da estrutura. Nosso objetivo é tornar esta estrutura genérica em uma estrutura total ou parcialmente persistente.

Consideramos que o número total de operações de modificação é~$m$, e o número de operações de acesso é~$a$. Da mesma forma, o número total de passos de modificação é~$M$ e de passos de acesso é~$A$. A $i$-ésima operação de modificação cria a versão~$i$ da estrutura. A versão~0 é a estrutura vazia. Se estamos considerando uma estrutura totalmente persistente, temos uma árvore de versões, caso contrário, uma lista.

Consideramos que cada operação recebe também, além de seus parâmetros normais (por exemplo, um valor para ser encontrado, no caso de uma busca em ABB) , um inteiro que indica sob qual versão deve ser feita essa operação. Dizemos que~$i \rightarrow j$ se a operação que cria a versão~$j$ é feita sobre a versão~$i$.

Note que, apesar de estarmos tratando apenas de estruturas ligadas, a versão persistente desta estrutura pode não ser ligada. Por exemplo, um dos métodos poderia armazenar um vetor de tamanho variável em cada nó, logo a estrutura deixaria de ser ligada.

\section{Off-line}

Em geral, estamos interessados em implementações on-line das estruturas persistentes, ou seja, uma operação deve ser completada para se ter acesso à próxima, porém, vamos considerar o caso off-line, em que todas as~$m+a$ operações são conhecidas de antemão. Obteremos uma implementação totalmente persistente que não faz nenhuma suposição adicional sobre a estrutura de dados, não aumenta assintoticamente o tempo consumido pelas operações, e gasta apenas~$\Oh(1)$ de espaço adicional por passo de modificação, que é o melhor que pode-se esperar.

Inicialmente, constrói-se a árvore de versões. O vértice~$v_i$ representa a versão~$i$. Neste deve-se armazenar, além da lista de adjacência~($v_k$ tal que~$i \rightarrow k$), a operação de modificação que criou a versão~$i$ (seus parâmetros), e uma lista das operações de acesso que são feitas na versão~$i$. Isso pode ser feito em tempo~$\Oh(m+a)$, ou seja, em tempo proporcional ao número de operações.
A Figura~\ref{fig:vertree_ex} mostra a árvore de versões do exemplo de pilha do Capítulo~\ref{cap:pilha_persist}.

\tikzset{
nodes = {draw, minimum size = 7mm},
edge from parent path = {(\tikzparentnode) -- (\tikzchildnode)},
sibling distance=20pt,
n/.style = {draw=none},
gr/.style = {color=gray},
edge from parent/.append style={-, shorten >= 0, shorten <= 0}
}
\begin{figure}
	\centering
	\begin{tikzpicture}
\Tree
[.\node(v0){\Call{Stack}{\null}};
	[.\node(v1){\Call{Push}{5}};
		[.\node(v2){\Call{Push}{7}};
			\node(v3){\Call{Push}{6}};
			[.\node(v4){\Call{Pop}{\null}};
				\node(v5){\Call{Push}{9}};
			]
		]
	]
	\node(v6){\Call{Push}{5}};
]

	\node[gr, above of = v3, xshift=-2.5em, yshift=0.5em](v3t){\Call{Top}{\null}};
	\draw[gr, -, shorten >= 2pt, shorten <= 2pt, dashed] (v3t) -- (v3);
	\node[gr, above of = v4, xshift=2.5em, yshift=0.5em](v4t){\Call{Top}{\null}};
	\draw[gr, -, shorten >= 2pt, shorten <= 2pt, dashed] (v4t) -- (v4);
	\end{tikzpicture}
	\caption{Árvore de versões do Exemplo~\ref{ex:pilha}, com argumentos para fazer cada operação de modificação indicados. Os nós mais claros (cinzentos) indicam as operações de acesso, conectadas à versão na qual são realizadas.} \label{fig:vertree_ex}
\end{figure}

Após montar a árvore de versões, realizamos uma busca em profundidade (DFS) nesta árvore, seguindo a seguinte ideia:
\begin{enumerate}
	\item Ao acessar um vértice~$v_i$ pela DFS, a estrutura está na versão~$j$, onde~$j \rightarrow i$.
	\item Aplicamos a operação, transformando a versão~$j$ em~$i$.
	\item Calculamos o valor de retorno para as operações de acesso feitas na versão~$i$ e em todas as versões descendentes de~$i$ recursivamente.
	\item Ao final do acesso ao vértice~$v_i$, revertemos as mudanças feitas, como explicado adiante, e a estrutura está novamente na versão~$j$.
\end{enumerate}

Dessa forma, no passo~3, podemos acessar os nós que são filhos de~$v_i$ recursivamente, já que, devido ao passo~4, quando o acesso a eles terminar, a versão da estrutura será a versão~$i$, e no passo~4 de~$v_i$ basta reverter as mudanças feitas nessa versão.

Para reverter mudanças de forma genérica, sempre que um passo de modificação altera um campo de um objeto, guardamos uma tripla~$(\V{obj}, \V{field}, \V{oldValue})$ indicando que o campo~$\V{field}$ do objeto~$\V{obj}$ mudou de valor, e seu valor anterior era~$\V{oldValue}$. Isso é informação o bastante para, ao final do procedimento, reverter essa mudança. Se o passo de modificação altera um nó de entrada, este também pode ser armazenado desta forma.

Como não impusemos restrições nas operações de mudança, elas podem modificar um mesmo campo muitas vezes. Logo, é necessário que o valor original seja restaurado, e não um valor intermediário. Para isso, desfazemos as mudanças na ordem inversa que foram feitas, usando uma pilha.

\begin{algorithm}
\caption{Persistência total off-line} \label{lst:geraloffline}
\begin{algorithmic}[1]

\Function{DFS}{$v_i$}
	\State $\V{mod} = \Call{Stack}{\null}$
	\State Aplicar a $i$-ésima operação de modificação, guardando valores antigos em~$\V{mod}$.\label{line:off:opmod}
	\State Responder todas as operações de acesso realizadas na versão~$i$. \label{line:off:opac}
	\For{$v_k \in$ lista de adjacência de $v_i$} \label{line:off:for}
		\State \Call{DFS}{$v_k$}
	\EndFor
	\While{$\V{mod}.\Call{Size}{\null} > 0$} \label{line:off:while}
		\State $(\V{obj}, \V{field}, \V{oldValue}) = \V{mod}.\Call{Pop}{\null}$
		\State $\V{obj}.\V{field} = \V{oldValue}$
	\EndWhile
\EndFunction

\Function{TotalPersistenceOffline}{\null}
	\State Montar a árvore de versões, com raiz~$v_0$.
	\State \Call{DFS}{$v_0$}
\EndFunction

\end{algorithmic}
\end{algorithm}

O Código~\ref{lst:geraloffline} mostra uma implementação, em alto nível, do algoritmo discutido. Assumimos que, ao realizar uma operação, seu valor de retorno seja armazenado em algum lugar. A operação na linha~\nref{line:off:opac} deve iterar pela lista de operações de acesso do vértice~$v_i$ e aplicá-las. Como assumimos que a ED começa na versão~0, temos que o vértice~$v_0$ é a raiz. A linha~\nref{line:off:opmod} não faz nada quando o vértice é~$v_0$.

\begin{proposition}
	Se a função~{\normalfont \Call{DFS}{$v_i$}} é chamada com a versão~$j$ da estrutura de dados, onde~${j \rightarrow i}$, então ela aplica corretamente todas as operações de acesso de alguma versão cujo vértice é descendente de~$v_i$. Além disso, ao final da execução da função, a versão da estrutura é~$j$.
\end{proposition}

\begin{proof}
A prova é por indução na altura de~$v_i$. No início da função, estamos na versão~$j$, então ao aplicar a operação~$i$, a estrutura muda para a versão~$i$. Além disso, todas as mudanças para reverter a versão~$i$ para~$j$ estão armazenadas em~$\V{mod}$.

A linha~\nref{line:off:opac} aplica as operações de acesso da versão~$i$. O~\keyword{for} da linha~\nref{line:off:for} chama, para cada filho de~$v_i$, a função~\textsc{DFS} neste. Seja~$v_x$ o primeiro filho acessado; pela hipótese de indução, como~$v_x$ tem altura menor que~$v_i$ e a estrutura está na versão~$i$ e~${i \rightarrow x}$, temos que a função aplica corretamente as operações de acesso das versões na sub-árvore de~$v_x$, e ao final da chamada de~\Call{DFS}{$v_x$}, a estrutura está novamente no estado~$i$.

Dessa forma, as chamadas da função~\textsc{DFS} para todos os filhos de~$v_i$ funcionam corretamente, e por isso as operações de acesso de todos os descendentes de~$v_i$ são realizadas. Por último, o~\keyword{while} da linha~\nref{line:off:while} desfaz as mudanças feitas na versão~$i$ e retorna a estrutura para a versão~$j$, completando a prova.
\end{proof}

Então, é possível transformar qualquer estrutura ligada em totalmente persistente, de forma off-line, com aumento no consumo de tempo de~$\Oh(M+A)$ e de espaço~$\Oh(M)$.

\section{Implementação funcional} \label{sec:implfuncional}

A técnica que usamos nas estruturas apresentadas até agora é tornar a implementação funcional, ou seja, nunca modificar nenhum campo de um nó já criado. Esse tipo de implementação é bastante ligada a linguagens funcionais, e implementações desta forma vão de pilhas a ABBBs~\cite{HoodMelville,KaplanT1999,Myers82,Myers83,Myers84}.

Se for possível implementar a estrutura desta forma, ela se torna totalmente persistente. De fato, se temos os nós de entrada da versão~$i$, e nenhum nó foi modificado, os nós que podem ser acessados a partir desses são exatamente os mesmos de quando a versão~$i$ foi criada, independente de versões criadas posteriormente. Logo, apenas armazenando os nós de entrada (e não apagando nenhum nó), tornamos nossa estrutura totalmente persistente.

Algumas estruturas ligadas já funcionam naturalmente dessa forma, como por exemplo a pilha implementada no Capítulo~\ref{cap:pilha_persist}, onde nunca é necessário alterar nenhum nó. Quando a estrutura não funciona dessa forma, é possível tentar ``forçar'' isso, copiando os nós que seriam modificados (e seus ancestrais). A estrutura recursiva de deque do Capítulo~\ref{cap:deque2_persist} faz isso, copiando todos os nós acessados durante um~\textsc{Push} ou~\textsc{Pop}.

Para fazer isso em uma estrutura qualquer, supomos que, sempre que adicionamos um nó~$u$ ao conjunto de acessos, todos seus ancestrais já estão neste conjunto. Ao adicionar esse nó, na verdade adicionamos uma cópia~$u'$ dele, e para todo nó~$v$ no conjunto de acessos que tem um ponteiro para~$u$, trocamos este ponteiro por~$u'$.

Note que nós no conjunto de acessos podem ser modificados, mas o importante é que nenhum nó criado em uma versão anterior é modificado, logo todas essas versões continuam funcionando.

\tikzset{
nodes={circle, minimum size=8mm},
n/.style = {draw=none},
b/.style = {fill=gray!40},
be/.style = {color=gray},
edge from parent/.append style={->, shorten >= 2pt, shorten <= 2pt}
}
\begin{figure}
	\centering
	\begin{tikzpicture}
		\Tree [.\node(a){$a$}; [.\node(b){$b$}; \node(d){$d$}; \edge[n];\node[n]{}; ] [.\node(c){$c$}; \node(e){$e$}; \edge[n];\node[n]{}; ] ]
	\end{tikzpicture}
	\begin{tikzpicture}
		\Tree [.\node(a){$a$}; [.\node(b){$b$}; \node(d){$d$}; \edge[n];\node[n]{}; ] [.\node(c){$c$}; \node(e){$e$}; \edge[n];\node[n]{}; ] ]
		\node[above of = a, b](al){$a'$};
		\draw[->, be] (al) -- (b);
		\draw[->, be] (al) -- (c);
	\end{tikzpicture}
	\begin{tikzpicture}
		\Tree [.\node(a){$a$}; [.\node(b){$b$}; \node(d){$d$}; \edge[n];\node[n]{}; ] [.\node(c){$c$}; \node(e){$e$}; \edge[n];\node[n]{}; ] ]
		\node[above of = a, b](al){$a'$};
		\node[above of = b, b](bl){$b'$};
		\draw[->, be] (al) -- (bl);
		\draw[->, be] (al) -- (c);
		\draw[->, be] (bl) to[out=230,in=90] (d);
	\end{tikzpicture}
	\begin{tikzpicture}
		\Tree [.\node(a){$a$}; [.\node(b){$b$}; \node(d){$d$}; \edge[n];\node[b](f){$f$}; ] [.\node(c){$c$}; \node(e){$e$}; \edge[n];\node[n]{}; ] ]
		\node[above of = a, b](al){$a'$};
		\node[above of = b, b](bl){$b'$};
		\draw[->, be] (al) -- (bl);
		\draw[->, be] (al) -- (c);
		\draw[->, be] (bl) to[out=230,in=90] (d);
		\draw[->, be] (bl) to[out=320,in=90] (f);
	\end{tikzpicture}
	\caption{Adição de um nó~$f$ à direita de~$b$ com uma implementação totalmente funcional. Em cinza, os nós criados ou copiados durante a adição.} \label{fig:totfunc_ex}
\end{figure}

A Figura~\ref{fig:totfunc_ex} mostra cada passo de uma operação de inserção em uma ABB usando esse método. Os nós que existiam no começo da operação não foram modificados, então a árvore ``visível'' a partir de~$a$ continua a mesma. Note que alguns nós são visíveis nas duas versões, como o~$d$ e o~$e$, já que não foram modificados (nem nenhum de seus descendentes). Se quiséssemos armazenar também ponteiros de pai em cada nó, uma implementação dessa forma não seria possível.

Supusemos que, ao adicionar um nó ao conjunto de acessos, todos seus ancestrais já estavam neste conjunto (na verdade, suas cópias), portanto não existe caminho de um nó não copiado para um nó que tem uma cópia no conjunto de acessos. Assim, todos os nós atingíveis a partir da nova versão ou são as cópias criadas ou são nós que nunca foram adicionados ao conjunto de acessos, ou seja, são exatamente os nós que seriam atingíveis se tivéssemos copiado a estrutura inteira. Logo, a estrutura ligada funciona e é totalmente persistente. Note que na Figura~\ref{fig:totfunc_ex} não é possível acessar, a partir de~$a'$, a versão anterior de um nó copiado (os nós~$a$ e~$b$).

Sem essa suposição, poderia ser possível alcançar a versão antiga de um nó que já foi copiado. Este foi o problema encontrado na primeira ideia de implementação da deque de Kaplan e Tarjan, como discutido na Seção~\ref{sec:implfunc}.

Note que, se os ponteiros da estrutura formam uma floresta direcionada, onde os nós de entrada são as raízes e as arestas vão em direção contrária às raízes, cada nó tem exatamente um caminho até ele, logo a suposição sobre adicionar um nó ao conjunto de acessos é sempre satisfeita, não importa a ordem na qual são feitas as adições ao conjunto de acessos. A estrutura discutida no Capítulo~\ref{cap:deque2_persist} é uma árvore direcionada, e na Seção~\ref{sec:implfunc} a implementação inicial discutida para a estrutura do Capítulo~\ref{cap:deque3_persist} é modificada para também se tornar uma árvore direcionada.

Assumindo que, ao adicionar um nó ao conjunto de acessos, as mudanças de ponteiros possam ser feitas em tempo constante (trivial em uma floresta direcionada), se a estrutura segue as restrições discutidas, esse método torna a estrutura totalmente persistente com aumento no consumo de tempo de~$\Oh(M+A)$ e espaço de~$\Oh(M+A_m)$, onde~$A_m$ é o número de passos de acesso que ocorrem durante operações de modificação, já que é necessário copiar o nó mesmo que este não seja modificado.


\section{Fat node}

É possível tornar uma estrutura ligada parcialmente persistente aumentando os seus nós para armazenar todas as mudanças já feitas. Essa técnica foi inicialmente apresentada por Driscoll, Sarnak, Sleator e Tarjan~\cite{DriscollSST1989}.

Modifica-se cada nó da estrutura para que cada campo seja substituído por um vetor de pares, que guarda pares~$(i, v)$, indicando que a~$i$-ésima operação de modificação alterou aquele campo para o valor~$v$. Em vez de modificar um campo de um objeto, adiciona-se um par no vetor correspondente, indicando a versão atual e o novo valor para o campo. Como estamos fazendo uma implementação parcialmente persistente, o índice de versão adicionado é sempre maior que todos os anteriores, dessa forma o vetor se mantém ordenado (considerando apenas os índices).

Para realizar um acesso ao campo~$c$ na versão~$i$, é necessário procurar no vetor associado a~$c$ o par com maior índice que não excede~$i$, ou seja, a última atualização feita até no máximo a versão~$i$. Isso pode ser feito com busca binária em tempo logarítmico no tamanho do vetor, já que a informação é armazenada em ordem. Diferente das outras técnicas, esta também aumenta o tempo de um passo de acesso.

Utilizar esta técnica transforma qualquer estrutura ligada em uma estrutura parcialmente persistente, com aumento no consumo de tempo de~$\Oh((M+A) \lg{M})$ e espaço de~$\Oh(M)$.

\section{Node copying} \label{sec:nodecopying}

No método Fat node, ao armazenar todas as modificações de um campo, precisamos de tempo logarítmico para descobrir o valor desse campo em uma dada versão. O método~\deff{Node copying} também consegue persistência parcial, mas diminui esse tempo, armazenando apenas um número constante de modificações em um mesmo nó, e fazendo uma cópia do nó quando este ficar muito grande. Este método também foi apresentado por Driscoll et al.~\cite{DriscollSST1989}.

Precisamos, contudo, fazer mais suposições sobre a estrutura. Supomos que os nós da estrutura ligada têm grau de entrada constante, ou seja, existe uma constante~$\V{in}$ tal que, a qualquer momento, para qualquer sequência de operações, vale que, para qualquer nó~$u$, o número de campos que tem ponteiros que apontam para~$u$, entre todos os nós da estrutura, é no máximo~$\V{in}$.

\newcommand{\changes}{\V{changes}}
\newcommand{\parents}{\V{parents}}
\newcommand{\ts}{\mathcal{T}}
\newcommand{\cp}{\V{copy}}
\newcommand{\version}{\V{version}}
\newcommand{\entry}{\V{entry}}

Cada nó deve armazenar, além de seus campos usuais, um vetor de triplas~$\V{changes}$ de tamanho~$\V{in}$ que armazena mudanças feitas nos seus campos, ou seja, se este vetor tem a tripla~${(\V{version}, \V{field}, \V{value})}$ então na versão~$\V{version}$ o campo~$\V{field}$ foi modificado para o valor~$\V{value}$. Esse vetor é inicialmente vazio, e armazena mudanças feitas ao nó depois de sua criação.

O método Node copying, como na implementação funcional, descrita na Seção~\ref{sec:implfuncional}, copia um nó~$u$ sempre que este é modificado em um passo de modificação. Após isso, é necessário modificar os ponteiros que apontam para~$u$. Para evitar ter que copiar todos os ancestrais de~$u$, guardamos estas modificações de ponteiros em seus campos~$\changes$, se estes tiverem espaço.

Se algum dos nós que apontam para~$u$ não tiver espaço livre em seu campo~$\changes$, uma cópia deste nó deve ser feita, armazenando a versão mais nova de cada campo (e deixando o vetor~$\changes$ vazio, no novo nó). Além disso, os nós que apontam para este devem ser modificados, o que pode gerar mais cópias.

Adicionamos um campo~$\ts$ a cada nó da estrutura, que é o índice da versão em que o nó foi criado, e um campo~$\cp$ que é um ponteiro para a cópia criada diretamente a partir deste nó, ou~\keyword{null} se não existir. Quando uma cópia é criada, a versão antiga do nó nunca mais é modificada, logo nenhuma outra cópia é criada diretamente a partir deste nó, apenas de suas cópias. Dessa forma, cada nó~$u$ representa o nó correspondente da estrutura no intervalo de versões~${[u.\ts, u.\cp.\ts - 1]}$ se este tiver cópia, caso contrário o nó representa a versão atual do nó correspondente na estrutura, e é chamado de~\emph{nó ativo}. Como estamos tratando de persistência parcial, apenas nós ativos são modificados.

\subsection{Implementações}

Como estamos lidando com estruturas de dados gerais, não apresentaremos pseudocódigo para as operações de acesso e modificação, que podem variar para cada estrutura, mas sim para uma interface que estas operações usam para acessar e modificar a estrutura.

\newcommand{\cur}{\V{current}}
Assumimos que um vetor~$\entry$ armazena todas as versões de nós de entrada. Dessa forma, operações de acesso podem acessar nós de entrada de qualquer versão em tempo constante. Além disso, assumimos que uma variável~$\cur$ armazena a versão atual da estrutura. No começo de toda operação de modificação esta variável deve ser incrementada, e os nós de entrada da versão anterior devem ser copiados para a nova versão.

Na Subseção~\textbf{Acesso}, apresentaremos a função~\textsc{Access}, que deve ser usada quando for necessário acessar um campo de um nó da estrutura, isto é, as operações de acesso devem usar~\mbox{\Call{Access}{$u, \V{field}, i$}} para acessar o campo~$\V{field}$ de~$u$ na versão~$i$, em vez de acessar o campo diretamente~($u.\V{field}$).

\newcommand{\auxfunc}[1]{\underline{#1}}

Na Subseção~\textbf{Modificação}, apresentaremos uma versão de~\textsc{Access} para ser usada durante operações de modificação, e também a função~\Call{Modify}{$u, \V{field}, \V{value}$}, que deve ser usada para modificar o campo~$\V{field}$ de~$u$ para o valor~$\V{value}$, em vez de fazer isso diretamente~($u.\V{field} = \V{value}$). As outras funções desenvolvidas nessa subseção são auxiliares, usadas direta ou indiretamente por~\mbox{\textsc{Access}} e~\textsc{Modify}. Para deixar isto claro, os nomes das funções auxiliares serão~\auxfunc{sublinhados}. % mudar isso?

\subsection{Acesso}

O acesso a um campo de um nó em uma dada versão pode ser feito como no Código~\ref{lst:acc_acc}. Note que estamos assumindo que as modificações estão armazenadas no vetor~$\V{changes}$ na ordem em que foram feitas.

\begin{algorithm}
\caption{Acesso a um campo durante uma operação de acesso.} \label{lst:acc_acc}
\begin{algorithmic}[1]

\Require $u$ representa a versão~$\V{version}$.
\Function{Access}{$u, \V{field}, \V{version}$}
	\State $\V{value} = u.\V{field}$
	\For{$(\V{version}', \V{field}', \V{value}') \in u.\V{changes}$}
		\If{$\V{field} = \V{field}' \And \V{version} \geq \V{version}'$}
			\State $\V{value} = \V{value}'$
		\EndIf
	\EndFor
	\State \Return $\V{value}$
\EndFunction

\end{algorithmic}
\end{algorithm}

Para retornar o valor do campo na versão~$\version$, aplicamos todas as modificações realizadas a este campo em versões que são no máximo~$\version$. Como o vetor~$\V{entry}$ armazena os nós de entrada de cada versão, com a função~\textsc{Access} é possível realizar uma operação de acesso em qualquer versão da estrutura com aumento constante no tempo por passo de acesso.

\subsection{Modificação}

Em uma operação de modificação, modificar um nó do conjunto de acessos pode levar à cópia de outros nós que já estão no conjunto de acessos. Para evitar que isso nos traga problemas, vamos garantir que no máximo uma cópia de cada vértice seja feita. Dessa forma, quando um passo de modificação da estrutura tentar acessar ou modificar um campo do vértice~$u$, ou~$u$ é ativo ou~$u.\cp$ existe e foi criado nesta versão.

A função~\Call{Access}{$u, \V{field}$} do Código~\ref{lst:acc_mod} funciona de forma parecida com a função~\Call{Access}{$u, \V{field}, \version$} do Código~\ref{lst:acc_acc}, mas sempre acessa a versão mais recente~($\cur$) do campo. Esta função não é usada em nenhuma das funções apresentadas no resto da seção, mas, como discutido, deve ser usada pelos~\emph{passos de acesso} na operação de modificação da estrutura de dados. A função~\Call{\auxfunc{Active}}{$u$} é usada como função auxiliar em muitas funções apresentadas nesta seção, e retorna a versão ativa do nó~$u$ (ou seja,~$u$ ou~$u.\cp$).

\begin{algorithm}
\caption{Acesso a um campo durante uma operação de modificação.} \label{lst:acc_mod}
\begin{algorithmic}[1]

\Require $u$ é ativo ou sua cópia foi criada nessa versão.
\Function{Access}{$u, \V{field}$}
	\State \Return \Call{Access}{$\Call{\auxfunc{Active}}{u}, \V{field}, \cur$}
\EndFunction

\Require $u$ é ativo ou sua cópia foi criada nessa versão.
\Function{\auxfunc{Active}}{$u$}
	\If{$u = \Null \Or u.\cp = \Null$}
		\State \Return $u$
	\Else
		\State \Return $u.\cp$
	\EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

Para poder atualizar os ponteiros de nós ativos que apontam para um nó~$u$, armazenamos em~$u$ um vetor~$\V{parents}$, de~$\V{in}$ posições, que armazena quais nós ativos apontam para~$u$. Se~$u$ não é ativo, esse vetor tem apenas~\keyword{null}s. Dizemos que~$\V{parents}$ armazena~\deff{ponteiros de volta}.

Quando um campo de ponteiro de um nó~$x$ é alterado de~$y$ para~$z$, é necessário atualizar o vetor~$\V{parents}$ de~$y$ e~$z$, removendo~$x$ do vetor de~$y$ e adicionando-o ao vetor de~$z$. A função~\mbox{\Call{\auxfunc{ChangeParent}}{$u, a, b$}} modifica o vetor~$u.\V{parents}$, trocando uma ocorrência de~$a$ por~$b$. A função~\mbox{\Call{\auxfunc{ChangePointer}}{$u, \V{field}, \V{value}$}} muda o ponteiro~$u.\V{field}$ para~$\V{value}$ (usando~\textsc{ChangeParent}, se necessário); essa função assume que o nó~$u$ foi criado nesta versão, portanto podemos mudar diretamente seus campos, sem ser necessário adicionar mudanças ao vetor~$\changes$. O Código~\ref{lst:chng_par_ptr} mostra a implementação destas duas funções.

\begin{algorithm}
\caption{Implementação de~\textsc{\auxfunc{ChangeParent}} e~\textsc{\auxfunc{ChangePointer}}.} \label{lst:chng_par_ptr}
\begin{algorithmic}[1]

\Function{\auxfunc{ChangeParent}}{$u, a, b$}
	\For{$i = 1 \To \V{in}$}
		\If{$u.\V{parents}[i] = a$}
			\State $u.\V{parents}[i] = b$
			\State \Break
		\EndIf
	\EndFor
\EndFunction

\Require $u$ é um nó criado nesta versão.
\Require $\V{field}$ é um campo de ponteiro.
\Function{\auxfunc{ChangePointer}}{$u, \V{field}, \V{value}$}
	\If{$u.\V{field} \neq \Null$}
		\State \Call{\auxfunc{ChangeParent}}{$u.\V{field}, u, \Null$}
	\EndIf
	\State $u.\V{field} = \Call{\auxfunc{Active}}{\V{value}}$ \Comment{$\V{value}$ pode já ter sido copiado.}
	\If{$u.\V{field} \neq \Null$}
		\State \Call{\auxfunc{ChangeParent}}{$u.\V{field}, \Null, u$}
	\EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

A função~\Call{\auxfunc{ChangeParent}}{$u, a, b$} funciona se o vetor~$\V{parents}$ está atualizado pois, ao trocar~$a$ por~$b$, se~$a \neq \Null$, então~$a$ apontava para~$u$, logo estava em~$\parents$; se~$a = \Null$, então, como~$\V{in}$ é o grau de entrada máximo de um nó, pelo menos uma posição do vetor tem o valor~$\Null$.

\begin{algorithm}
\caption{Modificação feita por um passo de modificação.} \label{lst:modify}
\begin{algorithmic}[1]

\Require $u$ é ativo ou sua cópia foi criada na versão atual~($\cur$).
\Function{Modify}{$u, \V{field}, \V{value}$}
	\State $u = \Call{\auxfunc{Active}}{u}$ \label{line:modify:active}
	\If{$u.\V{version} < \cur$} \label{line:modify:if2}
		\State $u.\cp = \Call{\auxfunc{Copy}}{u}$ \label{line:modify:copy}
		\State $u = u.\cp$
	\EndIf
	\If{$\V{field}$ é campo de ponteiro} \label{line:modify:chngb}
		\State \Call{\auxfunc{ChangePointer}}{$u, \V{field}, \V{value}$}
	\Else
		\State $u.\V{field} = \V{value}$
		\EndIf \label{line:modify:chnge}
\EndFunction

\end{algorithmic}
\end{algorithm}

A função~\Call{Modify}{$u, \V{field}, \V{value}$} modifica o campo~$\V{field}$ de~$u$, e deve ser chamada em passos de modificação da operação com índice~$\cur$. A função cria uma cópia do nó~$u$, se esta não existe e~$u$ não foi criado nessa versão (usando a função~\textsc{\auxfunc{Copy}}), e depois modifica o campo~$\V{field}$ diretamente, utilizando~\textsc{\auxfunc{ChangePointer}} se necessário.
O Código~\ref{lst:modify} mostra a implementação da função~\textsc{Modify}. O nó~$u$ é um nó do conjunto de acessos e, como discutido anteriormente, um destes casos ocorre:
\begin{itemize}
	\item $u$ tem uma cópia --- A chamada a~\textsc{\auxfunc{Active}} na linha~\nref{line:modify:active} troca~$u$ por esta cópia; ou
	\item $u$ não tem cópia e não foi criado nesta versão --- O~\keyword{if} da linha~\nref{line:modify:if2} cria uma cópia deste nó e troca~$u$ por esta cópia; ou
	\item $u$ foi criado nessa versão --- $u$ não é modificado.
\end{itemize}

Após qualquer um destes casos,~$u$ é um nó que foi criado nesta versão, e então as linhas~\nref{line:modify:chngb}-\nref{line:modify:chnge} mudam o campo~$\V{field}$.
Resta detalhar a função~\textsc{\auxfunc{Copy}}, que cria a cópia de um nó e modifica os ponteiros em nós ativos que apontam para ele.

\begin{algorithm}
\caption{Cópia de um nó na versão~$\cur$, atualizando os ponteiros que apontam para ele.} \label{lst:nc_copy}
\begin{algorithmic}[1]

\Function{\auxfunc{Copy}}{$u$}
	\State $u' = \Call{\auxfunc{RawCopy}}{u}$ \Comment{A função~\Call{\auxfunc{RawCopy}}{$u$} copia todos os campos de~$u$.}
	\State $u'.\V{changes} = \{\}$ \label{line:copy:chngb}
	\State $u'.\ts = \cur$
	\For{$(\V{version}', \V{field}', \V{value}') \in u.\V{changes}$}
		\State $u'.\V{field}' = \V{value}'$
	\EndFor \label{line:copy:chnge}
	\If{$u$ é nó de entrada} \label{line:copy:if1}
		\State Trocar~$u$ por~$u'$ na posição correta do vetor~$\V{entry}$.
	\EndIf
	\For{$\V{pointer} \in$ campos de ponteiros} \label{line:copy:for1}
		\If{$u'.\V{pointer} \neq \Null$}
			\State \Call{\auxfunc{ChangeParent}}{$u'.\V{pointer}, u, u'$}
		\EndIf
	\EndFor
	\State $u.\V{parents} = $ vetor apenas com~\keyword{null}s
	\For{$i = 1 \To |u'.\V{parents}|$} \label{line:copy:parents}
		\State $v = u'.\V{parents}[i]$
		\State $\V{field} = $ campo de~$v$ tal que~$v.\V{field} = u$.
		\If{$v.\ts = \cur$}
			\State $v.\V{field} = u'$
		\ElsIf{$|v.\V{changes}| < \V{in}$}
			\State $v.\V{changes}.\Call{Add}{(\cur, \V{field}, u')}$ \label{line:copy:changes}
		\Else
			\State $v.\cp = \Call{\auxfunc{Copy}}{v}$ \label{line:copy:copy}
			\State $v.\cp.\V{field} = u'$
			\State $u'.\V{parents}[i] = v.\cp$
		\EndIf
	\EndFor
	\State \Return $u'$
\EndFunction

\end{algorithmic}
\end{algorithm}

Assumimos que a função~\Call{\auxfunc{RawCopy}}{$u$} faz e retorna um novo nó com todos os campos iguais aos de~$u$. As linhas~\nref{line:copy:chngb}-\nref{line:copy:chnge} então modificam~$u'$ para este representar a versão mais atual de~$u$, aplicando todas as modificações de~$u.\changes$ e atualizando o campo~$\ts$. O~\keyword{if} da linha~\nref{line:copy:if1} lida com o caso em que~$u$ era um nó de entrada da versão~$\cur-1$, já que neste caso~$u'$ passa a ser o nó de entrada correspondente para a versão~$\cur$. O~\keyword{for} da linha~\nref{line:copy:for1} então muda os ponteiros de volta dos nós apontados por~$u$, já que agora~$u'$ é o nó ativo que aponta para eles. Por último, o~\keyword{for} da linha~\nref{line:copy:parents} modifica os ponteiros de nós ativos que apontavam para~$u$, fazendo-os apontar para~$u'$. Seja~$v$ um nó ativo tal que~$\Call{Access}{v, \V{field}} = u$, queremos que~$\Call{Access}{v, \V{field}} = u'$. Isso se reduz a três casos:
\begin{enumerate}
\item $v$ foi criado nessa versão --- Basta modificar diretamente o campo~$\V{field}$ em~$v$.
\item $v$ tem espaço livre em~$v.\changes$ --- Adicionamos a modificação ao vetor~$\changes$, ou seja, adicionamos a tripla~$(\V{field}, \cur, u')$ a~$\changes$.
\item $v$ não tem espaço livre em~$v.\changes$ --- Criamos uma cópia de~$v$, usando recursivamente a função~\textsc{\auxfunc{Copy}}, modificamos o campo~$\V{field}$ desta cópia, e atualizamos o vetor~$\parents$ de~$u'$ (que ainda aponta para~$v$ e não para~$v.\cp$).
\end{enumerate}

Como cada nó é copiado no máximo uma vez por versão, a função sempre termina.

\subsection{Análise de espaço e tempo}

A ideia do método é copiar os nós quando fazemos modificações em passos de modificação, mas guardam-se algumas modificações no mesmo nó para diminuir o número de cópias necessárias. É claro que, aumentando o tamanho do vetor~$\V{changes}$, o número de cópias diminui. Vamos mostrar que ter tamanho~$\V{in}$ é o bastante para que o método consuma espaço amortizado~$\Oh(1)$ por passo de modificação.

Utilizaremos o método do potencial. Seja~$E_i$ o estado da estrutura (persistente) na~$i$-ésima versão, ou seja, depois da~$i$-ésima operação de modificação. Vamos associar um valor~$\Phi(E_i)$ a cada uma das versões da estrutura, com~$\Phi(E_0) = 0$ e~$\Phi(E_i) \geq 0$ para todo~$i > 0$. Seja~$O_i$ o número de nós criados pelo método descrito na~$i$-ésima operação de modificação. Então
$$ \sum\limits_{i=1}^{m}{\left(O_i + \Phi(E_i) - \Phi(E_{i-1})\right)} = \left(\sum\limits_{i=1}^m{O_i}\right) + \Phi(E_m) - \Phi(E_0) \geq \sum\limits_{i=1}^m{O_i}. $$

Dessa forma, ainda que calcular~$O_i$ seja complicado, se escolhemos~$\Phi$ tal que o cálculo de~${O_i + \Phi(E_i) - \Phi(E_{i-1})}$ seja simples, conseguimos assim um limite superior para o número de nós criados pelo método, que é~$\sum\limits_{i=1}^m{O_i}$.

Queremos escolher~$\Phi$ de forma que~${O_i + \Phi(E_i) - \Phi(E_{i-1})}$ seja~$\Oh(M_i)$, onde~$M_i$ é o número de passos de modificação durante a~$i$-ésima operação de modificação. Para isso, queremos que o potencial ``cancele'' o número de nós adicionais, criados pelas chamadas recursivas de~\textsc{\auxfunc{Copy}}~(já que o número de nós criados em operações de modificação é no máximo~$M_i$). A escolha do potencial é~$\Phi(E_i) = A_i \cdot \V{in} - L_i$, onde~$A_i$ é o número de nós ativos em~$E_i$ e~$L_i$ é o número de espaços de modificação vazios em todos os nós ativos, ou seja, a soma do valor~$\V{in} - |u.\V{changes}|$ para todo nó ativo~$u$. Note que, como cada nó ativo tem no máximo~$\V{in}$ espaços livres,~$\Phi(E_i)$ nunca é negativo, e claramente~$\Phi(E_0) = 0$.

Segundo a definição, um passo de modificação cria um novo nó ou modifica um campo de um nó existente, usando para isso a função~\textsc{Modify}. Se um passo de modificação cria um novo nó, o potencial não se modifica, já que~$A_i$ aumenta em~1 e~$L_i$ aumenta em~$\V{in}$. Além disso,~$O_i$ aumenta em~1. Seja~$N_i$ o número de nós criados diretamente por passos de modificação durante a~$i$-ésima operação de modificação, ou seja, não são contadas cópias criadas por~\textsc{\auxfunc{Copy}}.

Vamos considerar nós criados pela função~\textsc{\auxfunc{Copy}} durante a~$i$-ésima operação de modificação. Esta função é uma função é uma função auxiliar e não é chamada diretamente durante os passos de modificação, apenas por~\textsc{Modify}~(linha~\nref{line:modify:copy}) e recursivamente pela própria~\textsc{\auxfunc{Copy}}~(linha~\nref{line:copy:copy}). Seja~$C_i$ o número de chamadas de~\textsc{\auxfunc{Copy}} feitas por~\textsc{Modify} e~$D_i$ o número de chamadas de~\textsc{\auxfunc{Copy}} feitas por~\textsc{\auxfunc{Copy}}.

Temos que~$C_i \leq M_i$, já que~\textsc{Modify} chama~\textsc{\auxfunc{Copy}} no máximo uma vez. Além disso, quando~\Call{\auxfunc{Copy}}{$u$} é chamada recursivamente, isso ocorreu pois~$u$ tinha o vetor~$\changes$ cheio, logo o potencial diminui em~$\V{in}$ nesse caso, já que o número de nós ativos~($A_i$) não muda, mas temos~$\V{in}$ mais espaços livres~($L_i$).

O~\keyword{for} da linha~\nref{line:copy:parents} pode adicionar mudanças aos vetores~$\V{changes}$ dos nós que apontam para~$u$~(linha~\nref{line:copy:changes}), aumentando~$\Phi$. Seja~$y$ a quantidade de tais adições. Cada chamada de~\textsc{\auxfunc{Copy}} pode adicionar até~$\V{in}$ modificações, porém, quando~\textsc{\auxfunc{Copy}} é chamada recursivamente na linha~\nref{line:copy:copy}, essa adição não é feita, logo~$y \leq (C_i + D_i) \cdot \V{in} - D_i$. Utilizando a notação definida acima temos:

\begin{align*}
	O_i + \Phi(E_i) - \Phi(E_{i-1}) & = N_i + C_i + D_i - D_i \cdot \V{in} + y
	\\ &\stackrel{\text{(1)}}{\leq} N_i + (1 + \V{in})\cdot C_i
	\\ &\stackrel{\text{(2)}}{=} N_i + (1 + \V{in}) \cdot M_i
	\\ &\stackrel{\text{(3)}}{=} \Oh(M_i)
\end{align*}

A desigualdade (1) vale pois~$y \leq (C_i + D_i) \cdot \V{in} - D_i$, e assim cancelamos~$D_i$, (2) vale pois~$C_i \leq M_i$ e~(3) usa que~$N_i \leq M_i$ e~$\V{in}$ é uma constante.

Isso prova que o espaço total gasto pela estrutura é~${\Oh(\sum\limits_{i=1}^m{M_i}) = \Oh(M)}$, ou seja, espaço amortizado constante por passo de modificação. Além disso, gasta-se tempo constante para criar cada nó, e cada chamada de~\textsc{\auxfunc{Copy}} cria um novo nó. Logo o consumo de tempo dos passos de modificação é limitado pela criação de nós, e os passos de acesso funcionam em tempo~$\Oh(1)$ usando a função~\textsc{Access}. Portanto, o tempo total consumido por esse método é~$\Oh(M+A)$, ou seja, tempo amortizado constante por passo de acesso ou modificação.

Concluindo, este método transforma qualquer estrutura ligada com grau de entrada limitado por uma constante em uma estrutura parcialmente persistente, sem aumentar o consumo de tempo assintoticamente, apenas deixando esse tempo amortizado (se já não era). Variações desta técnica também permitem deixar a estrutura totalmente persistente~\cite{DriscollSST1989}, porém, são bem mais complicadas e usam EDs adicionais.

\end{document}
