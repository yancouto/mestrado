\documentclass[../../main.tex]{subfiles}

\begin{document}

\chapter{Técnicas gerais} \label{cap:geral}

Nos capítulos anteriores, discutimos como tornar estruturas de dados específicas (pilhas, filas, deques) persistentes. Como dito na introdução, outro caminho é criar técnicas gerais para tornar qualquer ED persistente.


\section{Modelo de computação}

Para tomar uma abordagem tão geral, é necessário definir formalmente uma estrutura de dados.  Usaremos o modelo de~\deff{estruturas ligadas}, no qual uma estrutura de dados é um conjunto de \emph{nós}, ou \emph{objetos}, cada um contendo um número constante de campos. Cada campo pode armazenar um valor (um inteiro ou booleano, por exemplo) ou um ponteiro para outro nó. Ponteiros também podem armazenar o valor especial~\keyword{null}.  Acesso à estrutura é dado por um número constante de~\deff{nós de entrada}.

% XXX Preciso assumir que todos os nós são do mesmo tipo?

Uma pilha implementada com lista ligada, como no Capítulo~\ref{cap:pilha}, é uma estrutura desse tipo, onde o primeiro elemento da lista é o nó de entrada. A estrutura recursiva para deques do Capítulo~\ref{cap:deque2} também é dessa forma, e tem nós de~2 tipos, os nós da estrutura, e nós que são os pares. O nó de entrada também é o primeiro nó da estrutura.  Uma árvore de busca binária também é deste tipo, já que cada nó tem dois ponteiros (para o filho esquerdo e direito), e um valor; e a raiz é o nó de entrada.  A estrutura para deque do Capítulo~\ref{cap:deque1} não é deste tipo, pois o preprocessamento para o LA armazena em cada nó um vetor de tamanho~$\floor{\lg d}$, onde~$d$ é a altura do nó.

Vamos formalizar também as definições de operações de acesso e modificação. Uma~\deff{operação de acesso} produz um~\deff{conjunto de acesso}. No início da operação, este conjunto está vazio.  A cada passo, chamado de~\deff{passo de acesso}, adiciona-se um nó a este conjunto. O nó adicionado deve ser um nó de entrada ou deve ser indicado por um ponteiro em algum nó já no conjunto de acesso. O tempo consumido por uma operação de acesso é o número de passos de acesso. Operações também retornam valores, calculados usando seu conjunto de acesso.

A busca em uma ABB por um elemento é um exemplo de operação de acesso, que retorna se o elemento está ou não na ABB. Um exemplo mais complicado é a operação~\textsc{k-th} da deque recursiva, que primeiro encontra o nó da estrutura em que se localiza o $k$-ésimo elemento, e depois ``descasca'' os pares para encontrar e retornar este elemento.

Uma~\deff{operação de modificação} é parecida com uma de acesso. Ela consiste de passos de acesso, que funcionam da mesma forma, e~\deff{passos de modificação}. Em um passo de modificação, cria-se um novo nó, e este é adicionado ao conjunto de acesso, ou modifica-se um campo de algum nó do conjunto de acesso, ou modifica-se um nó de entrada. Se um ponteiro foi modificado, seu novo valor deve ser~\keyword{null} ou deve ser algum ponteiro do conjunto de acesso. O tempo consumido por esta operação é o número de passos, e o tempo de modificação é o número de passos de modificação.

Adicionar um elemento em uma ABB, por exemplo, consiste de achar sua posição, que pode levar até~$h$ passos de acesso, onde~$h$ é a altura da árvore, e criar um novo vértice ali, modificando um dos ponteiros desse nó. Logo esta operação consome tempo~$\Oh(h)$ e tempo de modificação~$\Oh(1)$.

Essas definições descrevem uma estrutura de dados efêmera, ou seja, operações de acesso e modificação podem apenas ser feitas na versão mais atual da estrutura. Nosso objetivo é tornar esta estrutura genérica em uma estrutura total ou parcialmente persistente.

Consideramos que o número total de operações de modificação é~$m$, e o número de operações de acesso é~$a$. Da mesma forma, o número total de passos de modificação é~$M$ e de passos de acesso é~$A$. A $i$-ésima operação de moficicação cria a versão~$i$ da estrutura. A versão~0 é a estrutura vazia. Se estamos considerando uma estrutura totalmente persistente, temos uma árvore de versões, caso contrário, uma lista.

Consideramos que cada operação recebe, além de seus parâmetros normais, também um inteiro que indica sob qual versão deve ser feita essa operação. Dizemos que~$i \rightarrow j$ se a operação que cria a versão~$j$ é feita sobre a versão~$i$.

Note que assumimos que a estrutura se encontra nesse modelo, mas nossas soluções podem não estar. Por exemplo, é muito comum armazenar um vetor com os nós de entrada para cada versão.

\section{Off-line}

Em geral, estamos interessados em implementações on-line das estruturas persistentes, ou seja, uma operação deve ser completada para se ter acesso à próxima, porém, vamos considerar o caso off-line, em que todas as~$m+a$ operações são conhecidas de antemão. Obteremos uma implementação totalmente persistente que não faz nenhuma suposição adicional sobre a estrutura de dados, não aumenta assintoticamente o tempo consumido pelas operações, e gasta apenas~$\Oh(1)$ de espaço adicional por passo de modificação, o melhor que pode-se esperar.

Inicialmente, constrói-se o grafo de versões. Em cada vértice desse grafo deve-se armazenar, além dos outros dados necessários (como uma lista de adjacência), a operação de modificação que criou aquela versão (seus parâmetros), e uma lista das operações de acesso que são feitas naquela versão. Isso pode ser feito em tempo~$\Oh(m+a)$, armazenando um vetor de nós, indexados pelo seu número de versão. O nó relacionado à~$i$-ésima versão é~$v_i$.

Queremos realizar uma busca em profundidade (DFS) nesta árvore, seguindo a seguinte ideia:
\begin{enumerate}
	\item Ao acessar um nó~$v_i$ pela DFS, a estrutura está na versão~$j$, onde~$j \rightarrow i$.
	\item Aplicamos a operação, transformando a versão em~$i$, e calculamos os retornos para as operações de acesso feitas em~$i$ e em todas as versões descendentes de~$i$.
	\item Ao final do acesso do nó~$v_i$, revertemos as mudanças feitas e a estrutura está novamente na versão~$j$.
\end{enumerate}

Dessa forma, no passo~2 podemos acessar os nós que são filhos de~$v_i$ recursivamente, já que, devido ao passo~3, quando o acesso a eles terminar, a versão da será a versão~$i$, e no passo~3 de~$v_i$ basta reverter as mudanças feitas nessa versão.

Para reverter mudanças de forma genérica, sempre que um passo de modificação altera um campo de um objeto, guardamos uma tripla~$(\V{obj}, \V{field}, \V{oldValue})$ indicando que o campo~$\V{field}$ do objeto~$\V{val}$ mudou de valor, e seu valor anterior era~$\V{oldValue}$. Isso é informação o bastante para, ao final do procedimento, reverter essa mudança. Se o passo de modificação altera um nó de entrada, este também pode ser armazenado desta forma.

Como não impusemos restrições nas operações de mudança, elas podem modificar um mesmo campo muitas vezes, logo é necessário que o valor original seja restaurado, e não um valor intermediário. Para isso, desfazemos as mudanças na ordem inversa que foram feitas, usando uma pilha.

\begin{algorithm}
\caption{Persistência total off-line} \label{lst:geraloffline}
\begin{algorithmic}[1]

\Function{DFS}{$v_i$}
	\State $\V{mod} = \Call{Stack}{\null}$
	\State Aplicar a $i$-ésima operação de modificação, guardando valores antigos em~$\V{mod}$.
	\State Responder todas as operações de acesso realizadas na versão~$i$. \label{line:off:opac}
	\For{$v_j \in$ lista de adjacência de $v_i$} \label{line:off:for}
		\State \Call{DFS}{$v_j$}
	\EndFor
	\While{$\V{mod}.\Call{Size}{\null} > 0$} \label{line:off:while}
		\State $(\V{obj}, \V{field}, \V{oldValue}) = \V{mod}.\Call{Pop}{\null}$
		\State $\V{obj}.\V{field} = \V{oldValue}$
	\EndWhile
\EndFunction

\Function{TotalPersistenceOffline}{\null}
	\State Montar o grafo de versões.
	\State \Call{DFS}{$v_0$}
\EndFunction

\end{algorithmic}
\end{algorithm}

O Código~\ref{lst:geraloffline} mostra uma implementação, em alto nível, do algoritmo discutido. Assumimos que, ao realizar uma operação, seu valor de retorno seja armazenado em algum lugar. A operação na linha~\nref{line:off:opac} deve iterar pela lista de operações de acesso no vértice~$v_i$ e aplicá-las.

\begin{proposition}
	Se a função~{\normalfont \Call{DFS}{$v_i$}} é chamada com a estrutura de dados na versão~$j$, onde~${j \rightarrow i}$, então ela aplica corretamente todas as operações de acesso de alguma versão cujo nó é descendente de~$v_i$. Além disso, ao final da execução da função, a versão da estrutura é~$j$.
\end{proposition}

\begin{proof}
A prova é por indução na altura de~$v_i$. No início da função, estamos na versão~$j$, então ao aplicar a operação~$i$, a estrutura muda para a versão~$i$. Além disso, todas as mudanças para reverter a versão~$i$ para~$j$ estão armazenadas em~$\V{mod}$.

A linha~\nref{line:off:opac} aplica as operações de acesso da versão~$i$. O~\keyword{for} da linha~\nref{line:off:for} chama, para cada filho de~$v_i$, a função~\textsc{DFS} deste. Seja~$v_x$ o primeiro filho acessado; pela hipótese de indução, como~$v_x$ tem altura menor que~$v_i$ e a estrutura está na versão~$i$ e~${i \rightarrow x}$, temos que a função aplica corretamente as operações de acesso das versões na sub-árvore de~$v_x$, e ao final da chamada desta, a estrutura está novamente no estado~$i$.

Dessa forma, as chamadas da função~\textsc{DFS} para todos os filhos de~$v_i$ são corretas, e por isso as operações de acesso de todos os descendentes de~$v_i$ são realizadas. Por último, o~\keyword{while} da linha~\nref{line:off:while} desfaz as mudanças feitas na versão~$i$ e retorna a estrutura para a versão~$j$, completando a prova.
\end{proof}

Então, é possível transformar qualquer estrutura ligada em totalmente persistente, de forma off-line, com overhead de consumo de tempo de~$\Oh(M+A)$ e~$\Oh(M)$ de espaço.

\section{Implementação funcional} \label{sec:implfuncional}

A técnica que usamos nas estruturas apresentadas até agora é tornar a implementação funcional, ou seja, nunca modificar nenhum campo de um nó já criado.

Se for possível implementar a estrutura desta forma, ela se torna totalmente persistente. Pois, se temos os nós de entrada da versão~$i$, e nenhum nó foi modificado, os nós que podem ser acessados a partir desses são exatamente os mesmos de quando a versão~$i$ foi criada, independente de versões criadas posteriormente. Logo, apenas armazenando os nós de entrada (e não apagando nenhum nó), tornamos nossa estrutura totalmente persistente.

Algumas estruturas ligadas já funcionam naturalmente dessa forma, como por exemplo a pilha implementada no Capítulo~\ref{cap:pilha}, nunca é necessário alterar nenhum nó. Quando a estrutura não funciona dessa forma, é possível tentar ``forçar'' isso. Durante operações de modificação podemos, ao adicionar um nó ao conjunto de acesso, adicionar na verdade uma cópia desse nó, já que ela pode vir a ser modificada por um passo de modificação.

A estrutura recursiva de deque do Capítulo~\ref{cap:deque2} faz isso, copiando todos os nós acessados durante um~\textsc{Push} ou~\textsc{Pop}. Isso sempre deixa a implementação funcional, já que não modificamos nenhum nó; porém, isso pode deixar a implementação inválida, já que pode ser possível alcançar a versão antiga de um nó que já foi copiado. Este foi o problema encontrado na implementação da deque de Kaplan e Tarjan, já que na primeira ideia de implementação, era possível acessar a versão antiga de um nó, como discutido na Seção~\ref{sec:implfunc}.

Esta técnica, de copiar todos os nós adicionados ao conjunto de acesso, funciona apenas se não existem nós atingíveis que não estão no conjunto de acesso e tem ponteiro para algum elemento cuja cópia está no conjunto de acesso. Se existe algum nó~$u$ desse tipo, então existe um caminho para~$u$, ou seja, uma sequência de passos de acesso que adicionam~$u$ ao conjunto de acesso, pois ele é atingível; e com mais um passo de acesso é possível adicionar a versão antiga do nó ao conjunto de acesso, que pode ter informação desatualizada.

Se os nós de estrutura formam uma árvore, como no caso da pilha e da deque recursiva, ou mesmo árvores binárias, então esse método pode ser aplicado. Na Seção~\ref{sec:implfunc}, a estrutura foi modificada para ser uma árvore, e dessa forma essa técnica poder ser aplicada.

Se a estrutura segue essas restrições, esse método torna estrutura totalmente persistente com overhead de consumo de tempo de~$\Oh(M+A)$ e espaço~$\Oh(M+A_m)$, onde~$A_m$ é o número de passos de acesso que ocorrem durante operações de modificação, já que é necessário copiar o nó mesmo que este não vá ser modificado.

\section{Fat node}

É possível alcançar persistência parcial em uma estrutura ligada genérica aumentando os seus nós para armazenar todas as mudanças já feitas. Essa técnica foi inicialmente apresentada por Driscoll, Sarnak, Sleator e Tarjan~\cite{DriscollSST1989}.

Modifica-se cada nó da estrutura para que cada campo seja substituido por um vetor de pares, que guarda pares~$(i, v)$, indicando que a~$i$-ésima operação de modificação modificou aquele campo para armazenar o valor~$v$. Ao invés de modificar um campo de um objeto, adicionasse um par no vetor correspondente, indicando a versão atual e o novo valor para o campo. Como estamos fazendo uma implementação parcialmente persistente, o índice de versão adicionado é sempre maior que todos os anteriores, dessa forma o vetor se mantém ordenado (considerando apenas os índices).

Para realizar um acesso do campo~$c$ na versão~$i$, é necessário procurar no vetor associado à~$c$ o par com maior índice que não excede~$i$, ou seja, a última atualização feita até no máximo a versão~$i$. Diferente das outras técnicas, esta também aumenta o tempo de um passo de acesso.

Utilizar esta técnica transforma qualquer estrutura ligada em uma estrutura parcialmente persistente, com overhead de consumo de tempo de~$\Oh((M+A) \lg{M})$ e espaço~$\Oh(M)$.

\section{Node copying} \label{sec:nodecopying}

No método Fat node, ao armazenar todas as modificações de um campo, precisamos de tempo logarítmico para descobrir o valor desse campo em uma dada versão. O método de~\deff{Node copying} diminui esse tempo armazenando apenas um número constante de versões em um mesmo nó, e fazendo uma cópia do nó quando este ficar muito grande. Este método também foi apresentado em~\cite{DriscollSST1989}.

Precisamos, contudo, fazer mais suposições sobre a estrutura. Supomos que os nós da estrutura ligada tem grau de entrada constante, ou seja, existe uma constante~$\V{in}$ tal que, a qualquer momento, para qualquer sequência de operações, vale que, para qualquer nó~$u$, o número de nós que tem em um de seus campos um ponteiro para~$u$ é no máximo~$\V{in}$.

Para representar um nó da estrutura efêmera, usaremos um nó persistente, que é um nó efêmero modificado, que pode armazenar até~$\V{in}$ modificações em seus campos. Quando um passo de modificação muda um campo do nó efêmero~$u_e$, criamos uma cópia~$u'$ do nó persistente~$u$, armazenando a versão atual de cada campo. Ao final da operação de modificação, é necessário atualizar cada nó~$v$ que tem ponteiros para nós copiados. Para fazer isso, se~$v$ não estiver cheio, armazenamos estas modificações em seus campos. Se está, o nó~$v$ é copiado, e recursivamente é necessário atualizar os nós que apontam para~$v$.

Um nó efêmero~$u_e$ é então representado por uma lista~$u_1, \ldots, u_k$ de nós persistentes. Se cada nó tem um campo~$\V{timestamp}$ que indica a versão em que foi criado, então o nó~$u_i$ representa~$u_e$ no intervalo de versões~$[u_i.\V{timestamp}, u_{i+1}.\V{timestamp}]$ para todo~$1 \leq i < k$, e o nó~$u_k$ representa~$u_e$ da versão~$u_k.\V{timestamp}$ até a versão atual. Este nó é chamado de nó~\deff{ativo}, pois representa~$u_e$ na versão atual da estrutura, e portanto, como estamos tratando de persistência parcial, é o único nó da lista que precisamos considerar ao fazer operações de modificação.

Cada nó~$u_i$ tem um campo~$\V{copy}$ que aponta para o próximo nó da lista, ou é~\keyword{null} se~$u_i$ é ativo~($i=k$). Para armazenar as mudanças, o nó~$u_i$ tem um vetor de triplas~$\V{changes}$ de tamanho~$\V{in}$ que armazena mudanças feitas nos campos de~$u_i$, ou seja, se este vetor tem a tripla~$(\V{version}, \V{field}, \V{value})$ então na versão~$\V{version}$ o campo~$\V{field}$ de~$u_i$ foi modificado para o valor~$\V{value}$.

\subsection{Acesso e modificação}

O acesso a um campo de um nó em uma dada versão pode ser feita da seguinte maneira. Note que estamos assumindo que as modificações estão armazenadas no vetor~$\V{changes}$ na ordem em que foram feitas.

\vspace{1em}
\hrule
\begin{algorithmic}[1]

\Function{Access}{$u, \V{field}, \V{version}$}
	\State $\V{value} = u.\V{field}$
	\For{$(\V{version}', \V{field}', \V{value}') \in u.\V{changes}$}
		\If{$\V{field} = \V{field}' \And \V{version} \geq \V{version}'$}
			\State $\V{value} = \V{value}'$
		\EndIf
	\EndFor
	\State \Return $\V{value}$
\EndFunction

\end{algorithmic}
\hrule
\vspace{1em}

A função~\Call{Access}{$u, \V{field}, \V{version}$} só funciona se~$u$ representa a versão~$\V{version}$.

Em uma mesma operação de modificação~$i$, vamos garantir que no máximo uma cópia de cada vértice seja feita, dessa forma, quando um passo de modificação mudar um campo do vértice~$u$, se~$u.\V{copy}$ existir, essa é a cópia de~$u$ e vale~$u.\V{copy}.\V{timestamp} = i$.
Para poder atualizar os ponteiros para um nó~$u$, armazenamos também um vetor~$\V{parents}$, de~$\V{in}$ posições, que armazena quais nós ativos apontam para~$u$. Se~$u$ não é ativo, esse vetor tem apenas~\keyword{null}s. Dizemos que~$\V{parents}$ armazena~\deff{ponteiros de volta}.

Quando um campo é modificado ou um nó é criado, é necessário atualizar o vetor~$\V{parents}$ dos nós relacionados. A função~\Call{ChangeParent}{$u, a, b$} modifica o vetor~$u.\V{parents}$, trocando uma ocorrência de~$a$ por~$b$. O código abaixo modifica um campo de um nó, e deve ser chamada em um passo de modificação da~$\V{version}$-ésima operação de modificação.

\vspace{1em}
\hrule
\begin{algorithmic}[1]

\Require $u$ é ativo ou era ativo no começo da operação de modificação.
\Function{Modify}{$u, \V{field}, \V{value}, \V{version}$}
	\If{$u.\V{copy} \neq \Null$}
		\State $u = u.\V{copy}$
	\EndIf
	\If{$u.\V{version} < \V{version}$}
		\State $u.\V{copy} = \Call{Copy}{u, \V{version}}$ \label{line:modify:copy}
		\State $u = u.\V{copy}$
	\EndIf
	\If{$\V{field}$ é campo de ponteiro}
		\State \Call{ChangeField}{$u, \V{field}, \V{value}$}
	\Else
		\State $u.\V{field} = \V{value}$
	\EndIf
\EndFunction

\Require $u$ é um nó criado nesta versão. \Comment{Não é necessário usar \textsc{Access}}
\Require $\V{field}$ é um campo de ponteiro.
\Function{ChangeField}{$u, \V{field}, \V{value}$}
	\If{$u.\V{field} \neq \Null$}
		\State \Call{ChangeParent}{$u.\V{field}, u, \Null$}
	\EndIf
	\State $u.\V{field} = \V{value}$
	\If{$\V{value} \neq \Null$}
		\State \Call{ChangeParent}{$\V{value}, \Null, u$}
	\EndIf
\EndFunction

\Function{ChangeParent}{$u, a, b$}
	\For{$i = 1 \To \V{in}$}
		\If{$u.\V{parents}[i] = a$}
			\State $u.\V{parents}[i] = b$
			\State \Return
		\EndIf
	\EndFor
\EndFunction

\end{algorithmic}
\hrule
\vspace{1em}

A função~\Call{ChangeParent}{$u, a, b$} funciona se o vetor~$\V{parents}$ está atualizado pois, ao trocar~$a$ por~$b$, se~$a \neq \Null$, então~$a$ apontava para~$u$, logo estava em parents; se~$a = \Null$, então, como~$\V{in}$ é o grau de entrada máximo de um nó, pelo menos uma posição do vetor tem o valor~$\Null$.

Se~$u$ não foi criado nessa versão e não tem cópia, a função~\Call{Modify}{$u, \V{field}, \V{value}, \V{version}$} copia~$u$, utilizando~\Call{Copy}{$u, \V{version}$}, que copia o nó~$u$ e retorna a cópia, modificando apropriadamente os vetores~$\V{parent}$ e os nós que apontam para~$u$. Após isso, o campo~$\V{field}$ é alterdo utilizando a função~\textsc{ChangeField}, que apenas modifica o valor em um nó criado na versão atual, arrumando os vetores de volta usando~\textsc{ChangeParent}. Se o campo não é um ponteiro, não é necessário chamar~\textsc{ChangeField}.
A função~\textsc{Copy} é da seguinte forma.

\vspace{1em}
\hrule
\begin{algorithmic}[1]

\Function{Copy}{$u, \V{version}$}
	\State $u' = \Call{RawCopy}{u}$
	\State $u.\V{parents} = $ vetor apenas com~\keyword{null}s
	\State $u'.\V{changes} = \{\}$
	\State $u'.\V{timestamp} = \V{version}$
	\For{$(\V{version}', \V{field}', \V{value}') \in u.\V{changes}$}
		\State $u'.\V{field}' = \V{value}'$
	\EndFor
	\If{$u$ é nó de acesso}
		\State Trocar~$u$ por~$u'$ na posição de vetor correspondente.
	\EndIf
	\For{$p \in$ campos de ponteiros}
		\If{$u'.p \neq \Null$}
			\State \Call{ChangeParent}{$u'.p, u, u'$}
		\EndIf
	\EndFor
	\For{$v \in u'.\V{parents}$} \label{line:copy:parents}
		\State $\V{field} = $ campo de~$v$ com valor~$u$.
		\If{$v.\V{timestamp} = \V{version}$} \Comment{$\V{parents}$ não precisa ser atualizado pois foi copiado de~$u$.}
			\State $v.\V{field} = u'$
		\ElsIf{$|v.\V{changes}| < \V{in}$}
			\State $v.\V{changes}.\Call{Add}{(\V{version}, \V{field}, u')}$
		\Else
			\State $v.\V{copy} = \Call{Copy}{v, \V{version}}$ \label{line:copy:copy}
			\State $v.\V{copy}.\V{field} = u'$
		\EndIf
	\EndFor
	\State \Return $u'$
\EndFunction

\end{algorithmic}
\hrule
\vspace{1em}

Assumimos que a função~\Call{RawCopy}{$u$} faz e retorna um novo nó com todos os campos iguais os de~$u$.
A função~\textsc{Copy} então ``aplica'' todas as modificações em~$\V{changes}$ ao nó~$u'$, e modifica todos os ponteiros de volta dos nós que ele aponta. Depois disso, resta modificar os nós que apontam para~$u$, para fazê-los apontar para~$u'$. Esse passo pode fazer necessária uma cópia de tal nó, usando a própria função~\textsc{Copy}. Como cada nó é copiado no máximo uma vez por versão, a função sempre termina.

\subsection{Análise de espaço e tempo}

A ideia do método é copiar os nós quando fazemos modificações, mas guardam-se algumas versões no mesmo nó para diminuir o número de cópias necessárias. É claro que, aumentando o tamanho do vetor~$\V{changes}$, o número de cópias diminui. Vamos mostrar que ter tamanho~$\V{in}$ é o bastante para que o método consuma espaço amortizado~$\Oh(1)$ por passo de modificação.

Utilizaremos o método do potencial, isso é, seja~$E_i$ o estado da estrutura (persistente) na~$i$-ésima versão, ou seja, depois da~$i$-ésima operação de modificação. Vamos associar um valor não negativo~$\Phi(E_i)$ a cada uma das versões da estrutura, tal que~$\Phi(E_0) = 0$. Seja~$O_i$ o número de nós criados pelo método descrito na~$i$-ésima operação de modificação, então
$$ \sum\limits_{i=1}^{m}{O_i + \Phi(E_i) - \Phi(E_{i-1})} = \left(\sum\limits_{i=1}^m{O_i}\right) + \Phi(E_m) - \Phi(E_0) \geq \sum\limits_{i=1}^m{O_i} $$

Dessa forma, ainda que calcular~$O_i$ seja complicado, se escolhemos~$\Phi$ tal que seja simples calcular~${O_i + \Phi(E_i) - \Phi(E_{i-1})}$, conseguimos assim um limite superior para o número de nós criado pelo método, que é~$\sum\limits_{i=1}^m{O_i}$.

Queremos escolher~$\Phi$ de forma que~${O_i + \Phi(E_i) - \Phi(E_{i-1})}$ seja~$\Oh(M_i)$, onde~$M_i$ é o número de passos de modificação durante a~$i$-ésima operação de modificação. Para isso, queremos que o potencial ``cancele'' o número de nós adicionais, criados pelas chamadas recursivas de~\textsc{Copy}. A escolha do potencial é~$\Phi(E_i) = A_i \cdot \V{in} - L_i$, onde~$A_i$ é o número de nós ativos em~$E_i$ e~$L_i$ é o número de espaços de modificação vazios em todos os nós ativos, ou seja, o valor~$\V{in} - |u.\V{changes}|$ para todo nó ativo~$u$. Note que como cada nó ativo tem no máximo~$\V{in}$ espaços livres,~$\Phi(E_i)$ nunca é negativo, e claramente~$\Phi(E_0) = 0$.

Se um passo de modificação cria um novo nó, o potencial não se modifica, já que~$A_i$ aumenta em~1 e~$L_i$ aumenta em~$\V{in}$, e~$O_i$ aumenta em~1. Seja~$N_i$ o número de nós criados.

Vamos considerar a função~\Call{Copy}{$u, i$}, a única outra função que cria nós. Seja~$C_i$ o número de chamadas à função~\textsc{Copy} na~$i$-ésima operação de modificação. Quando~\textsc{Copy} é chamada na linha~\nref{line:copy:copy} da função~\textsc{Copy}, é garantido que~$u$ tem seu vetor~$\V{changes}$ cheio. A única outra chamada à~\textsc{Copy} é na linha~\nref{line:modify:copy} de~\textsc{Modify}, e neste caso pode ser que o vetor~$\V{changes}$ não esteja cheio. Então, pelo menos~$C_i - M_i$ chamadas de~\textsc{Copy} são feitas quando~$u$ está cheio, e cada uma dessas chamadas diminui~$\Phi$ em~$\V{in}$, pois o novo nó é ativo e tem o vetor~$\V{changes}$ vazio. Seja~$x \geq C_i - M_i$ o número de tais chamadas.

O for da linha~\nref{line:copy:parents} pode adicionar mudanças aos vetores~$\V{changes}$ dos nós, aumentando~$\Phi$. Seja~$y$ a quantidade de tais adições. Cada nó pode adicionar até~$\V{in}$ modificações, porém, quando~\textsc{Copy} é chamada recursivamente na linha~\nref{line:copy:copy}, a adição da modificação não é feita, logo~$y \leq C_i \cdot \V{in} - x$. Utilizando a notação definida acima temos:

\begin{align*}
	O_i + \Phi(E_i) - \Phi(E_{i-1}) & = N_i + C_i - t \cdot \V{in} + y
	\\ &\stackrel{\text{(1)}}{\leq} N_i + (1 + \V{in})\cdot C_i - (1 + \V{in}) \cdot x
	\\ &\stackrel{\text{(2)}}{\leq} N_i + (1 + \V{in})\cdot C_i - (1 + \V{in}) \cdot (C_i - M_i)
	\\ &\stackrel{\text{(3)}}{=} N_i + (1 + \V{in}) \cdot M_i
	\\ &\stackrel{\text{(4)}}{=} \Oh(M_i)
\end{align*}

A relação (1) vale pois~$y \leq C_i \cdot \V{in} - x$, (2) vale pois~$x \geq C_i - M_i$,~(3) é uma simplificação da linha acima e~(4) usa que~$N_i \leq M_i$ e~$\V{in}$ é uma constante.

Isso prova que o espaço amortizado gasto pela estrutura é~${\Oh(\sum\limits_{i=1}^m{M_i}) = \Oh(M)}$. Além disso, gasta-se tempo constante para criar cada nó, e cada chamada de~\textsc{Copy} cria um novo nó, logo o consumo de tempo dos passos de modificação é limitado pela criação de nós, e os passos de acesso funcionam em tempo~$\Oh(1)$ usando a função~\textsc{Access}, logo o tempo amortizado consumido por esse método é~$\Oh(M+A)$.

Concluindo, este método transforma qualquer estrutura ligada com grau de entrada constante em uma estrutura parcialmente persistente, sem aumentar o consumo de tempo assintóticamente, apenas deixando esse tempo amortizado (se já não era). Variações desta técnica também permitem deixar a estrutura totalmente persistente~\cite{DriscollSST1989}, porém, são bem mais complicadas e usam EDs adicionais.



\end{document}
