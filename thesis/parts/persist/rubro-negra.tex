\documentclass[../../main.tex]{subfiles}

\begin{document}

\chapter{Árvore rubro-negra} \label{cap:rubronegra}

Iremos implementar uma árvore rubro-negra utilizando a técnica de Node copying, discutida na Seção~\ref{sec:nodecopying}. Uma árvore rubro-negra é uma árvore de busca binária balanceada, na qual cada nó é vermelho ou preto, e as cores são usadas para auxiliar no rebalanceamento.

Com uma implementação baseada na de Cormen et. al~\cite{CormenRedBlack}, a cada inserção ou remoção em uma árvore de~$n$ nós, são necessárias apenas~$\Oh(1)$ rotações para rebalancear a árvore, e~$\Oh(\lg n)$ mudanças de cores. Como as cores servem apenas para auxiliar no rebalanceamento, não é necessário que estes dados persistam, ou seja, só precisamos saber a cor dos nós ativos, logo apenas~$\Oh(1)$ passos de modificação~(considerando apenas os ponteiros de filho esquerdo e direito de um nó) por inserção, logo esta implementação parcialmente persistente consome tempo~$\Oh((m + a) \lg(m))$ e espaço~$\Oh(m)$, onde~$m$ é o número de operações de modificação~(inserções e remoções), e~$a$ é o número de operações de acesso~(acessar um elemento, seu teto ou chão, mínimo, etc.).

A implementação de Sedgewick e Wayne~\cite{SedgewickRedBlack}, apesar de ser considerada mais simples, não serve para os nossos propósitos, pois, ao considerar apenas árvores rubro-negras esquerdistas, os algoritmos de inserção e remoção podem realizar~$\Theta(\lg n)$ rotações, logo não é possível manter o consumo de espaço~$\Oh(m)$.

Se~$\Oh(m \lg m)$ de espaço é aceitável, uma implementação funcional garante esse espaço, e é totalmente persistente. Esse método é discutido na Seção~\ref{sec:implfuncional}, e também usado nos capítulos~\ref{cap:pilha},~\ref{cap:deque1},~\ref{cap:deque2} e~\ref{cap:deque3}. Basta, em operações de modificação, copiar todo o caminho percorrido na árvore, a partir da raiz.

\section{Definições}

Uma árvore de busca binária é uma árvore em que cada nó possui um valor, e tem no máximo dois filhos (esquerdo e direito). Para todo nó, o valor de todos os nós em sua subárvore esquerda é menor ou igual ao seu valor, e o valor de todos os nós em sua subárvore direita é maior ou igual ao seu valor.

Um nó que não tem algum filho armazena~\keyword{null} no campo correspondente a esse filho. Uma folha é um nó que não tem filhos, e um link nulo é um campo de filho de algum nó que tem valor~\keyword{null}, na Figura~\ref{fig:arv_bin_ex} são as arestas tracejadas.

\tikzset{
nodes = {draw, circle, minimum size = 8mm},
edge from parent path = {(\tikzparentnode) -- (\tikzchildnode)},
sibling distance=20pt,
n/.style = {draw=none},
r/.style = {fill=white},
b/.style = {fill=gray},
edge from parent/.append style={-, shorten >= 0, shorten <= 0}
}

\begin{figure}
\centering
\begin{tikzpicture}[
ed/.style = {densely dashed, shorten >= 5pt}]
\Tree [.\node[b]{7}; [.\node[b]{5}; [.\node[r]{1}; \edge[ed];\node[n]{}; \edge[ed];\node[n]{}; ] \edge[ed];[.\node[n]{}; ] ] [.\node[b]{10}; [.\node[r]{8}; \edge[ed];\node[n]{}; \edge[ed];\node[n]{}; ] \edge[ed];[.\node[n]{}; ] ] ]
\end{tikzpicture}
\caption{Exemplo de árvore rubro-negra. Como no resto das figuras do capítulo, os nós negros tem fundo cinza e os nós vermelhos tem fundo branco. Nas próximas figuras, o valor de cada nó não é especificado.} \label{fig:arv_bin_ex}
\end{figure}

Uma árvore rubro-negra segue as seguintes propriedades rubro-negras:
\begin{enumerate}
\item A raiz é preta.
\item Se um nó é vermelho, este não tem filhos vermelhos.
\item Para todo nó, todos os caminhos até links nulos de sua subárvore têm o mesmo número de nós pretos.
\end{enumerate}

Considerando apenas os nós pretos, a árvore é totalmente balanceada (propriedade 3). Como um nó vermelho não tem filhos vermelhos (propriedade 2), é possível ``juntar'' os nós vermelhos aos seus pais pretos (a raiz não é vermelha pela propriedade 1), e assim cada nó preto fica associado até~3 valores (e pode ter até 4 filhos). Logo, um simples limitante superior para a altura de uma árvore rubro-negra de~$n$ nós é~$3\floor{\lg(n)}$, pois esta árvore comprimida é totalmente balanceada. Se mantivermos as propriedades rubro-negras a cada inserção ou remoção, e o consumo de tempo destas operações for proporcional à altura da árvore, então o consumo de tempo será~$\Oh(\lg n)$ para todas as operações.

\section{Implementação da persistência}

\newcommand{\ts}{\mathcal{T}}
\newcommand{\cp}{\V{copy}}
\newcommand{\child}{\V{child}}
\newcommand{\parent}{\V{parent}}
\newcommand{\red}{\V{red}}
\newcommand{\extra}{\V{extra}}
\newcommand{\eSide}{\V{extraSide}}
\newcommand{\eTs}{\V{extra\mathcal{T}}}
\newcommand{\version}{\V{version}}
\newcommand{\side}{\V{side}}
\newcommand{\roots}{\V{roots}}
\newcommand{\val}{\V{value}}
\newcommand{\cur}{\V{current}}


Em uma árvore rubro-negra efêmera (não-persistente), todo nó precisa de dois campos para seus filhos, e um valor booleano que indica se o nó é vermelho. Como já discutido, o campo booleano não precisa ser guardado de forma persistente. Como cada nó tem grau de entrada no máximo~1, na versão persistente é necessário armazenar apenas um ponteiro de volta e um ponteiro extra por nó.

O ponteiro de volta é armazenado no campo~$\parent$, e é exatamente o ponteiro que aponta para o pai de um nó, o que será conveniente durante a implementação das operações. Note que, de acordo com a implementação da Seção~\ref{sec:nodecopying}, o campo~$\parent$ é nulo para nós que não são ativos, logo não pode ser utilizado para realizar as operações de acesso, apenas de modificação.

Para evitar a necessidade de replicar código muito parecido, vamos armazenar os filhos como um vetor~$\child$ de~2 posições,~$u.\child[0]$ é o filho esquerdo de~$u$, e~$u.\child[1]$ é seu filho direito. Dessa forma, casos simétricos podem ser tratados com o mesmo código. Os campos de um nó serão:
\begin{itemize}
\item $\ts$ --- Tempo de criação do nó.
\item $\cp$ --- Cópia do nó (se ele não é ativo).
\item $\child$ --- Vetor de filhos.
\item $\parent$ --- Ponteiro de volta.
\item $\red$ --- Booleano que indica se o nó é vermelho.
\item $\extra, \eSide, \eTs$ --- Ponteiro extra, seu lado e tempo de modificação.
\item $\val$ --- O valor armazenado pelo nó
\end{itemize}

Note que é necessário armazenar~$\eSide$, o lado do ponteiro extra, pois ele pode ser tanto um filho esquerdo quanto direito do nó, e se~$\extra$ for nulo, não há como saber qual filho este é comparando seu valor com o do nó. Para indicar se o ponteiro extra foi utilizado, usaremos que~$\eTs = -1$ quando não existe tal ponteiro.

\section{Operações de acesso}

Para acessar o campo de um nó na versão~$\version$, ou na versão ativa, usamos versões modificadas das funções~\textsc{Access}.

\begin{algorithm}
\caption{Acesso aos campos de um nó.}
\begin{algorithmic}[1]

\Require $u$ deve ser um nó associado à versão~$\version$.
\Function{Child}{$u, \side, \version$}
	\If{$u.\eTs \neq -1 \And u.\eSide = \side \And \version \geq u.\eTs$}
		\State \Return $u.\extra$
	\EndIf
	\State \Return $u.\child[\side]$
\EndFunction

\Require $u$ deve ser ativo ou sua cópia deve ter sido criada na versão atual.
\Function{Child}{$u, \side$}
\State \Return \Call{Child}{$\Call{Active}{u}, \side, \cur$} \Comment{\textsc{Active} funciona exatamente como descrito no Código~\ref{lst:acc_mod}.}
\EndFunction

\end{algorithmic}
\end{algorithm}

Vamos apresentar a operação de~\textsc{Find}, que retorna o valor buscado, ou~\keyword{null} se ele não foi encontrado. Assumimos que é guardado um vetor~$\roots$, com o nó de entrada (a raiz) para cada versão.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Find}{$x, \version$}
	\State $u = \roots[\version]$
	\While{$u \neq \Null \And x \neq u.\val$}
	\State $u = \Call{Child}{u, [x > u.\val], \version}$ \label{line:findrb:iver}
	\EndWhile
	\If{$u = \Null$}
		\State \Return \Null
	\Else
		\State \Return $x.\val$
	\EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

O algoritmo funciona como em uma árvore efêmera, mas usando a função~\textsc{Child} para acessar o filho direito ou esquerdo, em vez de utilizar o campo~$\child$, que pode não ter a versão desejada do ponteiro. Note que, na linha~\nref{line:findrb:iver}, já utilizamos a notação de~Iverson para diminuir o código. Outras operações de acesso (chão e teto, por exemplo) podem ser implementadas da mesma forma.

\section{Modificação de um campo}

Vamos apresentar as funções~\textsc{Modify} e~\textsc{Copy}, adaptadas da Seção~\ref{sec:nodecopying}, para utilizar durante as operações de modificação, que serão apresentadas nas próximas seções. No código, usamos que apenas ponteiros são modificados em nós de uma árvore rubro-negra, nunca o valor dos nós.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Modify}{$u, \side, v$}
	\State $u = \Call{Active}{u}$
	\If{$u.\ts < \cur$}
		\State $u.\cp = \Call{Copy}{u}$
		\State $u = u.\cp$
	\EndIf
	\If{$u.\child[\side] \neq \Null$}
		\State $u.\child[\side].\parent = \Null$
	\EndIf
	\State $u.\child[\side] = \Call{Active}{v}$
	\If{$u.\child[\side] \neq \Null$}
		\State $u.\child[\side].\parent = u$
	\EndIf
\EndFunction

% Precisa revisar depois do commit
\Function{Copy}{$u$}
	\State $u' = \Call{RawCopy}{u}$
	\If{$u.\eTs \neq -1$}
		\State $u'.\child[u.\eSide] = u.\extra$
		\State $u'.\eTs = -1$ \Comment{Limpando o campo extra}
	\EndIf
	\State $u'.\ts = \cur$
	\If{$\roots[\cur] = u$}
		\State $\roots[\cur] = u'$
	\EndIf
	\For{$\side \in \{0, 1\}$}
		\If{$u'.\child[\side] \neq \Null$}
			\State $u'.\child[\side].\parent = u'$
		\EndIf
	\EndFor
	\State $u.\parent = \Null$
	\If{$u'.\parent \neq \Null$}
		\State $v = u'.\parent$
		\State $\side = [\Call{Child}{v, 1} = u]$ \label{line:copyrb:side}
		\If{$v.\ts = \cur$}
			\State $v.\child[\side] = u'$
		\ElsIf{$v.\eTs = -1$}
			\State $v.\eTs = \cur$
			\State $v.\extra = u'$
			\State $v.\eSide = \side$
		\Else
			\State $v.\cp = \Call{Copy}{v}$
			\State $v.\cp.\child[\side] = u'$
			\State $u'.\parent = v.\cp$
		\EndIf
	\EndIf
	\State \Return $u'$
\EndFunction

\end{algorithmic}
\end{algorithm}

Utilizamos que cada nó tem apenas um campo extra e ponteiro de volta para diminuir o código, e o vetor de filhos para evitar duplicação de código. Com estas funções prontas, é possível manter a persistência da estrutura, e nas próximas seções vamos discutir como implementar as operações de inserir e remover um valor de uma árvore rubro-negra.

Note que na linha~\nref{line:copyrb:side} devemos usar~$[\Call{Child}{v, 1} = u]$ e não~$[u'.\val > v.\val]$ pois o segunda predicado não funciona quando a ABB pode armazenar valores repetidos, já que~$v$ pode ter~2 filhos com o mesmo valor.

\section{Inserção em ABB}

Descreveremos a operação~\Call{Insert}{$\val$}, que insere o valor~$\val$ numa ABB (efêmera e não rubro-negra). Para fazer isso, criamos um novo nó~$x$, com valor~$\val$. Se a árvore está vazia, fazemos~$x$ ser a raiz, e claramente a árvore continua sendo uma ABB válida.

Se a árvore não está vazia, seguimos o caminho, a partir da raiz, dado pelo valor~$\val$ (similar a uma operação~\textsc{Find}). Ao analisar um nó, seguimos para seu filho direito se~$\val$ for maior que seu valor, e para seu filho esquerdo caso contrário. Quando encontrarmos um link nulo, substituimos este por~$x$. A árvore continua válida pois era válida inicialmente e, para todo ancestral de~$x$, este está no ``lado correto'', ou seja, se este ancestral tem valor menor que~$\val$ então~$x$ está em sua subárvore direita, e caso contrário em sua subárvore esquerda, pela forma como percorremos a árvore.

Note que é possível existirem valores repetidos na árvore, por isso na definição de ABB usamos que os nós na subárvore esquerda tem valores menores ou iguais e os nós da subárvore direita tem valores maiores ou iguais ao valor do nó.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Insert}{$\val$}
	\State $x = \New \Call{Node}{\val}$ \Comment{Nó com valor $\val$ e outros campos vazios.}
	\If{$\V{root} = \Null$}
		\State $\V{root} = x$
	\Else
		\State $u = \V{root}$
		\While{$u \neq \Null$} \Comment{$v$ é o pai de~$u$.}
			\State $v = u$
			\State $u = u.\child[[\val > u.\val]]$
		\EndWhile
		\State $v.\child[[\val > v.\val]] = x$
	\EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Inserção em rubro-negra}

A inserção em uma árvore rubro-negra começa exatamente como a de uma ABB simples, porém pintamos~$x$ de vermelho.
Se a árvore era vazia,~$x$ é a raiz e apenas a propriedade~1 é violada. Caso contrário, apenas a propriedade~2 pode estar sendo violada, caso o pai de~$x$ seja vermelho. A propriedade~3 sempre continua a valer, pois adicionamos um nó vermelho.

Para arrumar a possível violação da propriedade, vamos fazer um laço com as seguintes invariantes (valem no começo da iteração do laço):
\begin{enumerate}[(A)]
\item $x$ é vermelho
\item Se~$x$ é a raiz, a propriedade~1 é violada.
\item Se~$x$ tem pai vermelho, a propriedade~2 é violada.
\item As propriedades não são violadas por outros vértices.
\end{enumerate}

Numa iteração deste laço, vamos ou acabar com todas as violações, ou mudar~$x$ para um nó de altura menor. Dessa forma ``subimos'' a violação, e conseguimos acabar com todas as violações em tempo~$\Oh(\lg n)$, pois a árvore é balanceada.

Se, no começo da iteração, a raiz é~$x$, então para arrumar esta violação basta pintar~$x$ de preto. Caso contrário, vamos recolorir ou rotacionar vértices, sempre mantendo a propriedade~3, para diminuir a altura do vértice que viola as propriedades.

\subsection{Rotações}

Rotações são modificações locais de nós de uma ABB que mantém as propriedades de uma ABB. Elas serão usadas para ``subir'' a violação na árvore rubro-negra. Uma rotação troca um nó~$u$ por um de seus filhos, fazendo as modificações necessárias para manter as propriedades de uma~ABB.

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}[local bounding box=scope1]
\Tree [.$u$ \node[n]{$\alpha$}; [.$v$ \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}
\begin{scope}[xshift=6cm, local bounding box=scope2]
\Tree [.$v$ [.$u$ \node[n]{$\alpha$}; \node[n]{$\beta$}; ] \node[n]{$\gamma$}; ]
\end{scope}

%\draw (0cm, 9cm) grid (6cm, 3cm);
\draw[->] (2cm, 0cm) -- node [n, yshift=1em] {\Call{Rotate}{$u, 1$}}  (4cm, 0cm);
\draw[->] (4cm, -3em) -- node [n, yshift=1em] {\Call{Rotate}{$v, 0$}}  (2cm, -3em);

\end{tikzpicture}
\caption{Exemplo de rotação direita e esquerda em uma ABB. Os símbolos~$\alpha,~\beta$ e~$\gamma$ indicam subárvores, possivelmente vazias.} \label{fig:rot_ex}
\end{figure}

A Figura~\ref{fig:rot_ex} mostra uma rotação genérica. Note que, nos dois lados da figura, com certo abuso de notação, temos~${\alpha \leq u \leq \beta \leq v \leq \gamma}$, isto é, se as propriedades de ABBs são seguidas em um lado da figura, elas continuam a ser respeitadas no outro lado da figura, após a rotação. % muito abuso de notação?

\subsection{Subindo a violação}

Se a árvore ainda tem violações no começo da iteração do laço, se $x$ não é a raiz, seja~$y$ o pai de~$x$. Temos que~$y$ é vermelho, logo não é a raiz (pois a propriedade~1 não é quebrada), e por isso também tem um pai~$z$ (o avô de~$x$). Como~$x$ é o único nó que viola alguma propriedade, seu avô~$z$ com certeza é preto. Seja~$w$ o tio de~$x$ (o filho de~$z$ que não é~$y$).


\begin{description}
	\item[Caso 1.] Se~$w$ existe e é vermelho, podemos apenas trocar as cores de~$y$,~$w$ e~$z$ para arrumar a violação de~$x$ (Figura~\ref{fig:rb_ins_caso1}). Todos os caminhos até links nulos que passam por~$z$ tem que passar por~$y$ ou~$w$, e como agora~$z$ é vermelho e~$y$ e~$w$ são pretos, o número de nós pretos nestes caminhos continuam os mesmos, e então a propriedade~3 se mantém.

	O nó~$x$ não viola mais nenhuma propriedade, mas o nó~$z$ se tornou vermelho e pode ter o pai vermelho ou ser a raiz, logo a próxima iteração deve ter~$x' = z$.

\item[Caso 2.] Caso contrário ($w$ não existe ou é preto), se~$x$ e~$y$ são filhos de mesmo lado (por exemplo,~$y$ é filho esquedo de~$z$ e~$x$ é filho esquerdo de~$y$), então realizamos uma rotação de~$z$ em direção à~$y$, e trocamos as cores de~$y$ e~$z$ (Figura~\ref{fig:rb_ins_caso2}).

	Os caminhos até links nulos que passam por~$x$ ou~$\alpha$ passam apenas pelo nó preto~$z$ nesta parte do caminho, antes da transformação, os caminhos que passam por~$w$ passam por~$z$ e~$w$ (se existir). Após a transformação, os caminhos até links nulos que passam por~$x$ ou~$\alpha$ passam apenas pelo nó preto~$y$, e os caminhos que passam por~$w$ apenas por este (se existir) e~$y$. Logo a propriedade~3 é mantida. O nó~$y$ é preto, logo não é possível que este viole as propriedades~1 ou~2, e por isso não existem mais iterações depois desta.

\item[Caso 3.] Se~$x$ e~$y$ são filhos de lados diferentes, a rotação feita no caso~2 não permite manter a propriedade~3, então primeiro fazemos uma rotação em~$y$ na direção de~$x$ (Figura~\ref{fig:rb_ins_caso3}), e assim transformamos este caso no~caso~2~(se trocamos~$x$ por~$y$).

\end{description}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[r]{$w$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[r]{$z$}; [.\node[b]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[b]{$w$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~1. Não importa se~$x$ é filho direito ou esquerdo.} \label{fig:rb_ins_caso1}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[b]{$w$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[b]{$y$}; [.\node[r]{$x$}; ] [.\node[r]{$z$}; \node[n]{$\alpha$}; \node[b]{$w$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~2, assumindo que~$x$ é filho esquerdo. Os nós~$x$ e~$w$ (se existir) podem ter filhos.} \label{fig:rb_ins_caso2}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[n]{$\alpha$}; [.\node[r]{$x$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ] [.\node[b]{$w$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[b]{$z$}; [.\node[r]{$x$}; [.\node[r]{$y$}; \node[n]{$\alpha$}; \node[n]{$\beta$}; ] \node[n]{$\gamma$}; ] [.\node[b]{$w$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~3, assumindo que~$x$ é filho direito. O nó~$w$, se existir, pode ter filhos.} \label{fig:rb_ins_caso3}
\end{figure}

Se o caso~1 é executado, o laço pode acabar, ou o nó~$x$ diminui de altura, se o caso~2 ou~3 são executados, o laço acaba. Como rotações podem ser feitas em tempo constante (são apenas algumas mudanças de ponteiros), a inserção em uma árvore rubro-negra efêmera de~$n$ nós consome tempo~$\Oh(\lg n)$.

\subsection{Implementação e persistência}

A maior parte das modificações envolvidas em uma inserção são mudanças de cores, que não precisam ser guardadas de forma persistente. Mudança de ponteiros só ocorrem para adicionar o nó~$x$ como filho de outro nó, e em possíveis rotações para tratar os casos~2 e~3. Como discutido, após um caso~2 ou~3 o algoritmo acaba, logo são feitas apenas~$\Oh(1)$ mudanças de ponteiros, e utilizando a persistência por Node copying conseguimos consumo de espaço amortizado constante por inserção.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Insert}{$\val$}
	\State $\roots[\cur] = \roots[\cur - 1]$
	\State $x = \New \Call{Node}{\val}$ \Comment{Nó vermelho com valor $\val$ e outros campos vazios.} \label{line:insrb:insb}
	\State $x.\ts = \cur$
	\If{$\roots[\cur] = \Null$}
		\State $\roots[\cur] = x$
	\Else
		\State $u = \roots[\cur]$
		\While{$u \neq \Null$} \Comment{$v$ é o pai de~$u$.} \label{line:insrb:whilefind}
			\State $v = u$
			\State $u = \Call{Child}{u, [\val > u.\val]}$
		\EndWhile
		\State \Call{Modify}{$v, [\val > v.\val], x$}
	\EndIf \label{line:insrb:inse}
	\LineComment{Arrumando a possível violação causada pelo nó~$x$.}
	\While{$x.\red \And x.\parent \neq \Null \And x.\parent.\red$} \label{line:insrb:loopb}
		\State $y = x.\parent$ \label{line:insrb:xyzwb}
		\State $z = y.\parent$
		\State $\V{sideX} = [x = \Call{Child}{y, 1}]$
		\State $\V{sideY} = [y = \Call{Child}{z, 1}]$ \label{line:insrb:xyzwe}
		\State $w = \Call{Child}{z, \Not\ \V{sideY}}$
		\If{$w \neq \Null \And w.\red$} \Comment{Caso 1.} \label{line:insrb:c1b}
			\State $z.\red = \True$
			\State $y.\red = \False$
			\State $w.\red = \False$
			\State $x = z$ \label{line:insrb:c1e}
		\Else
			\If{$\V{sideX} \neq \V{sideY}$} \Comment{Caso 3.} \label{line:insrb:c3b}
				\State \Call{Rotate}{$y, \V{sideX}$}
				\State $x, y = y, x$ \Comment{Trocando~$x$ e~$y$.} \label{line:insrv:c3e}
			\EndIf
			\State \Call{Rotate}{$z, \V{sideY}$} \Comment{Caso 2.} \label{line:insrb:c2b}
			\State $\Call{Active}{z}.\red = \True$ \label{line:insrb:act1}
			\State $\Call{Active}{y}.\red = \False$ \label{line:insrb:act2}
			\State \Break \label{line:insrb:c2e}
		\EndIf
	\EndWhile
	\State $\roots[\cur].\red = \False$ \Comment{Caso~$x$ seja a raiz, e vermelho.} \label{line:insrb:loope}
\EndFunction
\end{algorithmic}
\caption{Inserção em árvore rubro-negra parcialmente persistente.} \label{lst:ins_rb}
\end{algorithm}

O Código~\ref{lst:ins_rb} mostra então a implementação da inserção, como discutida, dado que a função~\mbox{\textsc{Rotate}} funciona corretamente. As linhas~\nref{line:insrb:insb}-\nref{line:insrb:inse} inserem o nó na árvore como em uma ABB normal, mas usando as funções~\textsc{Child} e~\textsc{Modify} para manter a persistência. As linhas~\nref{line:insrb:loopb}-\nref{line:insrb:loope} fazem o laço discutido nesta seção.

No começo da primeira iteração do laço, as propriedades valem pois~$x$ é um nó vermelho que recém-inserido. As linhas~\nref{line:insrb:xyzwb}-\nref{line:insrb:xyzwe} determinam os nós~$y$,~$z$ e~$w$, usados nos casos. O caso~1 é tratado nas linhas~\nref{line:insrb:c1b}-\nref{line:insrb:c1e}, trocando as cores de~$z$,~$y$ e~$w$ e fazendo o~$x$ da próxima iteração ser~$z$, pois é o único nó que possivelmente viola alguma propriedade.

O caso~3 é transformado no caso~2 nas linhas~\nref{line:insrb:c3b}-\nref{line:insrv:c3e}, fazendo uma rotação de~$y$ na direção de~$x$, e trocando esses~2 nós. As linhas~\nref{line:insrb:c2b}-\nref{line:insrb:c2e} então tratam o caso~2, fazendo uma rotação de~$z$ em direção à~$y$ e trocando a cor destes, como na Figura~\ref{fig:rb_ins_caso2}. As chamadas a~\textsc{Active} nas linhas~\nref{line:insrb:act1} e~\nref{line:insrb:act2} tratam o caso quando as rotações causaram cópias, e por isso~$y$ ou~$z$ não são mais ativos, pois para modificar o campo efêmero~$\red$ devemos modificar o nó ativo. Nestes dois casos o~\keyword{break} termina o laço.

Por último, a linha~\nref{line:insrb:loope} pinta a raiz de preto, já que o laço não trata esse caso e termina quando~$u$ não tem pai.

%% O(lgn) + O(1) amortizado
A função consome tempo amortizado~$\Oh(\lg n)$ pois a altura da árvore é~$\Oh(\lg n)$, ambos os lações das linhas~\nref{line:insrb:whilefind} e~\nref{line:insrb:loopb} realizam um número de iterações proporcional a altura, e a função~\textsc{Rotate} e~\textsc{Modify} consomem tempo (e espaço) amortizado constante. Como essas funções só são chamadas um número constante de vezes, o consumo de espaço é amortizado~$\Oh(1)$.

O Código~\ref{lst:rotrb} mostra a implementação da função~\textsc{Rotate}, que usa apenas um número constante de chamadas a~\textsc{Modify}. Note que é necessário, entre quaisquer duas chamadas, manter que cada vértice tem no máximo um outro vértice que aponta para ele, logo é preciso ter mais cuidado que com a implementação em uma ABB efêmera. Apesar das funções~\textsc{Child} e~\textsc{Modify} funcionarem se receberem nós que já foram copiados neste operação, na função~\textsc{Rotate} é necessário acessar o campo~$\parent$ de~$u$, por isso na linha~\nref{line:rotb:active} trocamos~$u$ por sua cópia, se existir.

\begin{algorithm}
\begin{algorithmic}[1]
\Require $u$ deve ter um filho~$\side$ na versão~$\cur$.
\Function{Rotate}{$u, \side$}
	\State $v = \Call{Child}{u, \side}$
	\State $\beta = \Call{Child}{v, \Not\ \side}$
	\State \Call{Modify}{$v, \Not\ \side, \Null$}
	\State \Call{Modify}{$u, \side, \beta$}
	\State $u = \Call{Active}{u}$ \label{line:rotrb:active}
	\If{$u.\parent \neq \Null$}
		\State \Call{Modify}{$u.\parent, [\Call{Child}{u.\parent, 1} = u], v$}
	\Else
		\State $\roots[\cur] = v$ \Comment{Se~$x$ não tiver pai este é a raiz.}
	\EndIf
	\State \Call{Modify}{$v, \Not\ \side, u$}
\EndFunction
\end{algorithmic}
\caption{Rotação em uma árvore rubro-negra parcialmente persistente.} \label{lst:rotrb}
\end{algorithm}

\end{document}
