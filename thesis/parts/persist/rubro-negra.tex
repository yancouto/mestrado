\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Árvore rubro-negra} \label{cap:rubronegra_persist}

Apresentaremos neste capítulo a implementação de uma árvore rubro-negra parcialmente persistente utilizando a técnica de node copying, discutida na Seção~\ref{sec:nodecopying}. Uma árvore rubro-negra é uma árvore de busca binária balanceada, na qual cada nó é vermelho ou preto, e as cores são usadas para auxiliar no rebalanceamento.

Com uma implementação baseada na de Cormen et al.~\cite[Cap. 13]{CLRS}, a cada inserção ou remoção em uma árvore de~$n$ nós, são necessárias apenas~$\Oh(1)$ rotações para rebalancear a árvore, e~$\Oh(\lg n)$ mudanças de cores. Como as cores servem apenas para auxiliar no rebalanceamento, não é necessário que estes dados sejam mantidos em versões que não a atual para persistência parcial. Ou seja, só precisamos saber a cor dos nós ativos, logo são feitos apenas~$\Oh(1)$ passos de modificação~(ignorando as mudanças de cores) por inserção, logo esta implementação parcialmente persistente consome tempo~$\Oh((m + a) \lg(m))$ e espaço~$\Oh(m)$, onde~$m$ é o número de operações de modificação~(inserções e remoções), e~$a$ é o número de operações de acesso~(acessar um elemento, mínimo, máximo, etc.).

A implementação de Sedgewick e Wayne~\cite{Sedgewick}, apesar de ser considerada mais simples, não serve para os nossos propósitos, pois, ao considerar apenas árvores rubro-negras esquerdistas, os algoritmos de inserção e remoção podem realizar~$\Theta(\lg n)$ rotações, logo não é possível manter o consumo de espaço~$\Oh(m)$, usando node copying.

Se~$\Oh(m \lg m)$ de espaço é aceitável, é possível fazer uma implementação funcional de árvore rubro-negra. Esta implementação consome mais espaço que a implementação que vamos apresentar neste capítulo, mas é mais simples e é totalmente persistente. Esse método é discutido na Seção~\ref{sec:implfuncional}, e utilizado nos Capítulos~\ref{cap:pilha_persist},~\ref{cap:deque1_persist},~\ref{cap:deque2_persist} e~\ref{cap:deque3_persist}. Basta, em operações de modificação, copiar todo o caminho percorrido na árvore, a partir da raiz.

Estamos interessados na implementação das seguintes operações:

\begin{itemize}
	\item \funcAPI{Insert}{\V{value}}
		\\ Insere um nó com valor~$\V{value}$ na ABB.
	\item \funcAPI{Remove}{\V{value}}
		\\ Remove um nó com valor~$\V{value}$ da ABB.
	\item \funcAPI{Find}{\V{value}}
		\\ Devolve algum nó da ABB com valor~$\V{value}$. Caso não exista, devolve~\keyword{null}.
\end{itemize}

\section{Definições}

%Uma árvore de busca binária é uma árvore enraízada em que cada nó possui um valor, e tem no máximo dois filhos (esquerdo e direito). Para todo nó, o valor de todos os nós em sua subárvore esquerda é menor ou igual ao seu valor, e o valor de todos os nós em sua subárvore direita é maior ou igual ao seu valor.

Uma árvore binária consiste de um nó chamado raiz, que tem ponteiro para até duas outras árvores binárias, chamadas subárvore esquerda e subárvore direita. Uma árvore~\emph{de busca}~binária é uma árvore binária na qual cada nó tem um valor e segue a seguinte propriedade: para cada nó, o valor de todos os nós em sua subárvore esquerda é menor ou igual ao seu valor, e o valor de todos os nós em sua subárvore direita é maior ou igual ao seu valor.

Um nó que não tem algum filho armazena~\keyword{null} no campo correspondente a esse filho. Uma folha é um nó que não tem filhos, e um link nulo é um campo de filho de algum nó que tem valor~\keyword{null}. Na Figura~\ref{fig:arv_bin_ex} estes são as arestas tracejadas.

\tikzset{
nodes = {draw, circle, minimum size = 8mm},
edge from parent path = {(\tikzparentnode) -- (\tikzchildnode)},
sibling distance=20pt,
n/.style = {draw=none},
r/.style = {fill=white},
b/.style = {fill=gray},
edge from parent/.append style={-, shorten >= 0, shorten <= 0}
}

\begin{figure}
\centering
\begin{tikzpicture}[
ed/.style = {densely dashed, shorten >= 5pt}]
\Tree [.\node[b]{7}; [.\node[b]{5}; [.\node[r]{1}; \edge[ed];\node[n]{}; \edge[ed];\node[n]{}; ] \edge[ed];[.\node[n]{}; ] ] [.\node[b]{10}; [.\node[r]{8}; \edge[ed];\node[n]{}; \edge[ed];\node[n]{}; ] \edge[ed];[.\node[n]{}; ] ] ]
\end{tikzpicture}
\caption{Exemplo de árvore rubro-negra. Como no resto das figuras do capítulo, os nós negros têm fundo cinza e os nós vermelhos têm fundo branco. Nas próximas figuras, o valor de cada nó não é especificado.} \label{fig:arv_bin_ex}
\end{figure}

Uma árvore rubro-negra satisfaz as seguintes propriedades rubro-negras:
\begin{enumerate}
\item A raiz é negra.
\item Se um nó é vermelho, este não tem filhos vermelhos.
\item Para todo nó, todos os caminhos até links nulos de sua subárvore têm o mesmo número de nós negros.
\end{enumerate}

Considerando apenas os nós negros, a árvore é totalmente balanceada (propriedade 3). Como um nó vermelho não tem filhos vermelhos (propriedade 2), é possível ``juntar'' os nós vermelhos aos seus pais negros (a raiz não é vermelha pela propriedade 1), e assim cada nó negro fica associado a até três valores (e pode ter até quatro filhos). Logo, uma delimitação superior simples para a altura de uma árvore rubro-negra com~$n$ nós é~$3\floor{\lg(n)}$, pois esta árvore comprimida é totalmente balanceada. Se mantivermos as propriedades rubro-negras a cada inserção ou remoção, e o consumo de tempo destas operações for proporcional à altura da árvore, então o consumo de tempo será~$\Oh(\lg n)$ para todas as operações.

\section{Implementação da persistência}

\newcommand{\ts}{\mathcal{T}}
\newcommand{\cp}{\V{copy}}
\newcommand{\child}{\V{child}}
\newcommand{\parent}{\V{parent}}
\newcommand{\red}{\V{red}}
\newcommand{\extra}{\V{extra}}
\newcommand{\eSide}{\V{extraSide}}
\newcommand{\eTs}{\V{extra\mathcal{T}}}
\newcommand{\version}{\V{version}}
\newcommand{\side}{\V{side}}
\newcommand{\roots}{\V{roots}}
\newcommand{\val}{\V{value}}
\newcommand{\cur}{\V{current}}


Em uma árvore rubro-negra efêmera (não persistente), todo nó precisa de dois campos para seus filhos, e um valor booleano que indica se o nó é vermelho ou não. Como já discutido, o campo booleano não precisa ser guardado de forma persistente. Como cada nó tem grau de entrada no máximo~um, na versão persistente é necessário armazenar apenas um ponteiro de volta e um ponteiro extra por nó, dado que usaremos a técnica de node copying.

O ponteiro extra simula o vetor~$\V{changes}$ usado durante a Seção~\ref{sec:nodecopying}, que no caso sempre teria zero ou um elemento.

O ponteiro de volta é armazenado no campo~$\parent$, e é exatamente o ponteiro que aponta para o pai de um nó, o que será conveniente durante a implementação das operações. Note que, de acordo com a implementação da Seção~\ref{sec:nodecopying}, o campo~$\parent$ é nulo para nós que não são ativos, logo ele não pode ser utilizado para realizar as operações de acesso, apenas de modificação.

Para evitar a necessidade de replicar código muito parecido, vamos armazenar os filhos como um vetor~$\child$ de~duas posições;~$u.\child[0]$ é o filho esquerdo de~$u$, e~$u.\child[1]$ é seu filho direito. Dessa forma, casos simétricos podem ser tratados com o mesmo código. Os campos de um nó serão:
\begin{itemize}
\item $\val$ --- O valor armazenado no nó.
\item $\child$ --- Vetor de filhos.
\item $\parent$ --- Ponteiro de volta.
\item $\red$ --- Booleano que indica se o nó é vermelho ou não.
\item $\ts$ --- Instante de criação do nó.
\item $\cp$ --- Cópia do nó (se ele não é ativo).
\item $\extra, \eSide, \eTs$ --- Ponteiro extra, seu lado e instante de modificação.
\end{itemize}

É necessário armazenar apenas um ponteiro extra por nó, que pode ser de filho esquerdo ou direito. Note que é necessário armazenar~$\eSide$, o lado do ponteiro extra, pois se~$\extra$ for nulo, não há como saber qual filho este é apenas comparando seu valor com o do nó. Para indicar se o ponteiro extra foi utilizado, usaremos que~$\eTs = -1$ quando não existe tal ponteiro.

\section{Operações de acesso} \label{sec:rbacesso}

Para acessar o campo de um nó na versão~$\version$, ou na versão atual, usamos versões modificadas das funções~\textsc{Access}, dadas no Código~\ref{lst:arb_access} (neste capítulo, os nomes das funções de interface não estarão sublinhados para não serem confundidos com os nomes das operações da ABB). O campo~$\cur$, como na Seção~\ref{sec:nodecopying}, indica o tempo atual da estrutura, ou seja, o número de operações de modificação realizadas, e os campos~$\ts$ e~$\eTs$ armazenam o valor de~$\cur$ durante a criação do nó e do ponteiro extra, respectivamente.

\begin{algorithm}
	\caption{Acesso aos campos de um nó.} \label{lst:arb_access}
\begin{algorithmic}[1]

\Require $u$ deve ser um nó associado à versão~$\version$.
\Function{Child}{$u, \side, \version$}
	\If{$u.\eTs \neq -1 \AND u.\eSide = \side \AND \version \geq u.\eTs$}
		\State \Return $u.\extra$
	\EndIf
	\State \Return $u.\child[\side]$
\EndFunction

\Require $u$ deve ser ativo ou sua cópia deve ter sido criada na versão atual.
\Function{Child}{$u, \side$}
\State \Return \Call{Child}{$\Call{Active}{u}, \side, \cur$} \Comment{\textsc{Active} funciona como descrito no Código~\ref{lst:acc_mod}.}
\EndFunction

\end{algorithmic}
\end{algorithm}

O Código~\ref{lst:arb_find} apresenta a operação~\API{Find}, que devolve um nó com o valor buscado, ou~\keyword{null} se tal nó não existe. Assumimos que é guardado um vetor~$\roots$, com o nó de entrada (a raiz) para cada versão.

\begin{algorithm}
\begin{algorithmic}[1]

	\Function{\API{Find}}{$x, \version$}
	\State $u = \roots[\version]$
	\While{$u \neq \Null \AND x \neq u.\val$}
	\State $u = \Call{Child}{u, [x > u.\val], \version}$ \label{line:findrb:iver}
	\EndWhile
	\State \Return $u$
\EndFunction

\end{algorithmic}
	\caption{Operação~\API{Find} em uma ABB rubro-negra parcialmente persistente.} \label{lst:arb_find}
\end{algorithm}

O algoritmo funciona como em uma árvore efêmera, mas usando a função~\textsc{Child} para acessar o filho direito ou esquerdo, em vez de utilizar o campo~$\child$, que pode não ter a versão desejada do ponteiro. Note que, na linha~\nref{line:findrb:iver}, já utilizamos a notação de~Iverson para diminuir o código. Outras operações de acesso (encontrar o maior elemento menor ou igual a algum valor, por exemplo) podem ser implementadas da mesma forma.

\section{Modificação de um campo}

O Código~\ref{lst:rbmodify_copy} apresenta as funções~\textsc{Modify} e~\textsc{Copy}, adaptadas da Seção~\ref{sec:nodecopying}, para utilizar durante as operações de modificação, que serão apresentadas nas próximas seções. No código, usamos que apenas ponteiros são modificados em nós de uma árvore rubro-negra, nunca o valor dos nós.

\begin{algorithm}
\begin{algorithmic}[1]

\Require $v$ deve ser~\keyword{null} ou não ter pai.
\Function{Modify}{$u, \side, v$} \Comment{Faz~$v$ filho de~$u$ do lado~$\side$.}
	\State $u = \Call{Active}{u}$
	\If{$u.\ts < \cur$}
		\State $u.\cp = \Call{Copy}{u}$
		\State $u = u.\cp$
	\EndIf
	\If{$u.\child[\side] \neq \Null$}
		\State $u.\child[\side].\parent = \Null$
	\EndIf
	\State $u.\child[\side] = \Call{Active}{v}$
	\If{$u.\child[\side] \neq \Null$}
		\State $u.\child[\side].\parent = u$
	\EndIf
\EndFunction

\Function{Copy}{$u$}
	\State $u' = \Call{RawCopy}{u}$
	\State $u'.\ts = \cur$
	\If{$u.\eTs \neq -1$}
		\State $u'.\child[u.\eSide] = u.\extra$
		\State $u'.\eTs = -1$ \Comment{Limpando o campo extra.}
	\EndIf
	\If{$\roots[\cur] = u$}
		\State $\roots[\cur] = u'$
	\EndIf
	\For{$\side \in \{0, 1\}$}
		\If{$u'.\child[\side] \neq \Null$}
			\State $u'.\child[\side].\parent = u'$
		\EndIf
	\EndFor
	\State $u.\parent = \Null$
	\If{$u'.\parent \neq \Null$}
		\State $v = u'.\parent$
		\State $\side = [\Call{Child}{v, 1} = u]$ \label{line:copyrb:side}
		\If{$v.\ts = \cur$}
			\State $v.\child[\side] = u'$
		\ElsIf{$v.\eTs = -1$}
			\State $v.\eTs = \cur$
			\State $v.\extra = u'$
			\State $v.\eSide = \side$
		\Else
			\State $v.\cp = \Call{Copy}{v}$
			\State $v.\cp.\child[\side] = u'$
			\State $u'.\parent = v.\cp$
		\EndIf
	\EndIf
	\State \Return $u'$
\EndFunction

\end{algorithmic}
\caption{Funções~\textsc{Modify} e~\textsc{Copy}, adaptadas da Seção~\ref{sec:nodecopying}.} \label{lst:rbmodify_copy}
\end{algorithm}

Utilizamos que cada nó tem apenas um campo extra e ponteiro de volta para diminuir o código, e o vetor de filhos para evitar duplicação de código. Com estas funções prontas, é possível manter a persistência da estrutura, e nas próximas seções vamos discutir como implementar as operações de inserir e remover um valor de uma árvore rubro-negra.

Note que, na linha~\nref{line:copyrb:side} do Código~\ref{lst:rbmodify_copy}, devemos usar~$[\Call{Child}{v, 1} = u]$ e não~$[u'.\val > v.\val]$ pois o segundo predicado não funciona quando a ABB pode armazenar valores repetidos, já que~$v$ pode ter~dois filhos com o mesmo valor.

\section{Inserção em ABB}

Para inserir o valor~$\val$ em uma ABB efêmera e não rubro-negra, criamos um novo nó~$x$, com valor~$\val$. Se a árvore está vazia, fazemos~$x$ ser a raiz, e claramente a árvore continua sendo uma ABB válida.
Se a árvore não está vazia, seguimos o caminho, a partir da raiz, dado pelo valor~$\val$ (similar a uma operação~\API{Find}). Ao analisar um nó, seguimos para seu filho direito se~$\val$ for maior que seu valor, e para seu filho esquerdo caso contrário. Quando encontrarmos um link nulo, substituímos este por~$x$. A árvore continua válida pois era válida inicialmente e, para todo ancestral de~$x$, este está no ``lado correto'', ou seja, se este ancestral tem valor menor que~$\val$ então~$x$ está em sua subárvore direita, e caso contrário em sua subárvore esquerda, pela forma como percorremos a árvore.

Note que é possível existirem valores repetidos na árvore, por isso na definição de ABB usamos que os nós na subárvore esquerda têm valores menores ou iguais e os nós da subárvore direita têm valores maiores ou iguais ao valor do nó. O Código~\ref{lst:abb_insert} mostra a implementação da operação~\API{Insert}.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Insert}{$\val$}
	\State $x = \New \Call{Node}{\val}$ \Comment{Nó com valor $\val$ e outros campos vazios.}
	\If{$\V{root} = \Null$}
		\State $\V{root} = x$
	\Else
		\State $u = \V{root}$
		\While{$u \neq \Null$} \Comment{$v$ é o pai de~$u$.}
			\State $v = u$
			\State $u = u.\child[[\val > u.\val]]$
		\EndWhile
		\State $v.\child[[\val > v.\val]] = x$
	\EndIf
\EndFunction

\end{algorithmic}
\caption{Inserção em uma ABB efêmera e não rubro-negra.} \label{lst:abb_insert}
\end{algorithm}

\section{Inserção em rubro-negra}

A inserção em uma árvore rubro-negra começa exatamente como a de uma ABB simples, porém pintamos~$x$ de vermelho.
Se a árvore era vazia,~$x$ é a raiz e apenas a propriedade~1 é violada. Caso contrário, apenas a propriedade~2 pode estar sendo violada, caso o pai de~$x$ seja vermelho. A propriedade~3 sempre continua a valer, pois adicionamos um nó vermelho.

Para arrumar a possível violação da propriedade~1 ou~2, vamos fazer um laço com as seguintes invariantes (valem no começo da iteração do laço):
\begin{enumerate}[(A)]
\item $x$ é vermelho.
\item Se~$x$ é a raiz, a propriedade~1 é violada.
\item Se~$x$ tem pai vermelho, a propriedade~2 é violada.
\item As propriedades não são violadas por outros nós.
\end{enumerate}

Numa iteração deste laço, vamos ou acabar com todas as violações, ou mudar~$x$ para um nó de altura menor. Dessa forma ``subimos'' a violação, e conseguimos acabar com todas as violações em tempo~$\Oh(\lg n)$, pois a árvore é balanceada.

Se, no começo da iteração, a raiz é~$x$, então para arrumar esta violação basta pintar~$x$ de preto. Caso contrário, vamos recolorir ou rotacionar nós, sempre mantendo a propriedade~3, para diminuir a altura do nó que viola as propriedades.

\subsection{Rotações}

Rotações são modificações locais de nós de uma ABB que mantém as propriedades de uma ABB. Elas serão usadas para ``subir'' a violação na árvore rubro-negra. Uma rotação troca um nó~$u$ por um de seus filhos, fazendo as modificações necessárias para manter as propriedades de uma~ABB.

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}[local bounding box=scope1]
\Tree [.$u$ \node[n]{$\alpha$}; [.$v$ \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}
\begin{scope}[xshift=6cm, local bounding box=scope2]
\Tree [.$v$ [.$u$ \node[n]{$\alpha$}; \node[n]{$\beta$}; ] \node[n]{$\gamma$}; ]
\end{scope}

%\draw (0cm, 9cm) grid (6cm, 3cm);
\draw[->] (2cm, 0cm) -- node [n, yshift=1em] {\Call{Rotate}{$u, 1$}}  (4cm, 0cm);
\draw[->] (4cm, -3em) -- node [n, yshift=1em] {\Call{Rotate}{$v, 0$}}  (2cm, -3em);

\end{tikzpicture}
\caption{Exemplo de rotação direita e esquerda em uma ABB. Os símbolos~$\alpha,~\beta$ e~$\gamma$ indicam subárvores, possivelmente vazias.} \label{fig:rot_ex}
\end{figure}

A Figura~\ref{fig:rot_ex} mostra uma rotação genérica. Note que, nos dois lados da figura, com certo abuso de notação, temos~${\alpha \leq u \leq \beta \leq v \leq \gamma}$, isto é, se as propriedades de ABBs são seguidas em um lado da figura, elas continuam a ser respeitadas no outro lado da figura, após a rotação. Dizemos que~$u$ é rotacionado em direção a~$v$ no caso da chamada~\Call{Rotate}{$u, 1$}. % muito abuso de notação?

\subsection{Subindo a violação}

Se a árvore ainda tem violações no começo da iteração do laço, se $x$ não é a raiz, seja~$y$ o pai de~$x$. Temos que~$y$ é vermelho, logo não é a raiz (pois a propriedade~1 não é quebrada), e por isso também tem um pai~$z$ (o avô de~$x$). Como~$x$ é o único nó que viola alguma propriedade, seu avô~$z$ com certeza é preto. Seja~$w$ o tio de~$x$ (o filho de~$z$ que não é~$y$).


\begin{description}
	\item[Caso 1.] $w$ existe e é vermelho. Podemos apenas trocar as cores de~$y$,~$w$ e~$z$ para arrumar a violação de~$x$ (Figura~\ref{fig:rb_ins_caso1}). Todos os caminhos até links nulos que passam por~$z$ têm que passar por~$y$ ou~$w$, e como agora~$z$ é vermelho e~$y$ e~$w$ são negros, o número de nós negros nestes caminhos continuam os mesmos, e então a propriedade~3 se mantém.

	O nó~$x$ não viola mais nenhuma propriedade, mas o nó~$z$ se tornou vermelho e pode ter o pai vermelho ou ser a raiz, logo a próxima iteração deve ter~$x' = z$.

	\item[Caso 2.] $w$ não existe ou é preto, e~$x$ e~$y$ são filhos de mesmo lado (por exemplo,~$y$ é filho esquerdo de~$z$ e~$x$ é filho esquerdo de~$y$). Então realizamos uma rotação de~$z$ em direção a~$y$, e trocamos as cores de~$y$ e~$z$ (Figura~\ref{fig:rb_ins_caso2}).

	Antes da transformação: os caminhos até links nulos que passam por~$x$ ou~$\alpha$ passam apenas pelo nó negro~$z$ nesta parte do caminho, e os caminhos que passam por~$w$ passam pelos nós pretos~$z$ e~$w$ (se existir). Após a transformação: os caminhos até links nulos que passam por~$x$ ou~$\alpha$ passam apenas pelo nó negro~$y$, e os caminhos que passam por~$w$ passam pelos nós pretos~$y$ e $w$ (se existir). Logo a propriedade~3 é mantida. O nó~$y$ é preto, logo não é possível que este viole as propriedades~1 ou~2, e por isso não existem mais iterações depois desta.

	\item[Caso 3.] $w$ não existe ou é preto, e~$x$ e~$y$ são filhos de lados diferentes. A rotação feita no caso~2 não permite manter a propriedade~3, então primeiro fazemos uma rotação em~$y$ na direção de~$x$ (Figura~\ref{fig:rb_ins_caso3}), e assim transformamos este caso no~caso~2~(se trocamos~$x$ por~$y$).

\end{description}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[r]{$w$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[r]{$z$}; [.\node[b]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[b]{$w$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~1. Não importa se~$x$ é filho direito ou esquerdo.} \label{fig:rb_ins_caso1}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[r]{$x$}; \node[n]{$\alpha$}; ] [.\node[b]{$w$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[b]{$y$}; [.\node[r]{$x$}; ] [.\node[r]{$z$}; \node[n]{$\alpha$}; \node[b]{$w$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~2, assumindo que~$x$ é filho esquerdo. Os nós~$x$ e~$w$ (se existir) podem ter filhos.} \label{fig:rb_ins_caso2}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{scope}
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[n]{$\alpha$}; [.\node[r]{$x$}; \node[n]{$\beta$}; \node[n]{$\gamma$}; ] ] [.\node[b]{$w$}; ] ]
\end{scope}
\begin{scope}[xshift=8cm]
	\Tree [.\node[b]{$z$}; [.\node[r]{$x$}; [.\node[r]{$y$}; \node[n]{$\alpha$}; \node[n]{$\beta$}; ] \node[n]{$\gamma$}; ] [.\node[b]{$w$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~3, assumindo que~$x$ é filho direito. O nó~$w$, se existir, pode ter filhos.} \label{fig:rb_ins_caso3}
\end{figure}

Se o caso~2 ou~3 é executado, não existe mais violações de propriedade e o laço acaba. Se o caso~1 é executado, trocamos~$x$ por um nó de altura menor (que pode ser a raiz). Logo, o caso~1 ocorre no máximo~$h$ vezes, onde~$h$ é a altura da árvore. Como cada caso consiste apenas de rotações e mudanças de cores, e rotações podem ser feitas em tempo constante (são apenas algumas mudanças de ponteiros), a inserção em uma árvore rubro-negra efêmera de~$n$ nós consome tempo~$\Oh(\lg n)$, já que árvore é balanceada.

\subsection{Implementação e persistência parcial}

A maior parte das modificações envolvidas em uma inserção são mudanças de cores, que não precisam ser guardadas de forma persistente. Mudança de ponteiros só ocorrem para adicionar o nó~$x$ como filho de outro nó, e em possíveis rotações para tratar os casos~2 e~3. Como discutido, após um caso~2 ou~3, o algoritmo acaba, logo são feitas apenas~$\Oh(1)$ mudanças de ponteiros, e utilizando a persistência por node copying conseguimos consumo de espaço amortizado constante por inserção.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{Insert}{$\val$}
	\State $\cur = \cur + 1$
	\State $\roots[\cur] = \roots[\cur - 1]$
	\State $x = \New \Call{Node}{\val}$ \Comment{Nó vermelho com valor $\val$ e outros campos vazios.} \label{line:insrb:insb}
	\State $x.\ts = \cur$
	\If{$\roots[\cur] = \Null$}
		\State $\roots[\cur] = x$
	\Else
		\State $u = \roots[\cur]$
		\While{$u \neq \Null$} \Comment{$v$ é o pai de~$u$.} \label{line:insrb:whilefind}
			\State $v = u$
			\State $u = \Call{Child}{u, [\val > u.\val]}$
		\EndWhile
		\State \Call{Modify}{$v, [\val > v.\val], x$}
	\EndIf \label{line:insrb:inse}
	\LineComment{Arrumando a possível violação causada pelo nó~$x$.}
	\While{$x.\red \AND x.\parent \neq \Null \AND x.\parent.\red$} \label{line:insrb:loopb}
		\State $y = x.\parent$ \label{line:insrb:xyzwb}
		\State $z = y.\parent$
		\State $\V{sideX} = [\Call{Child}{y, 1} = x]$
		\State $\V{sideY} = [\Call{Child}{z, 1} = y]$ \label{line:insrb:xyzwe}
		\State $w = \Call{Child}{z, \Not\ \V{sideY}}$
		\If{$w \neq \Null \AND w.\red$} \Comment{Caso 1.} \label{line:insrb:c1b}
			\State $z.\red = \True$
			\State $y.\red = \False$
			\State $w.\red = \False$
			\State $x = z$ \label{line:insrb:c1e}
		\Else
			\If{$\V{sideX} \neq \V{sideY}$} \Comment{Caso 3.} \label{line:insrb:c3b}
				\State \Call{Rotate}{$y, \V{sideX}$}
				\State $x, y = y, x$ \Comment{Trocando~$x$ e~$y$.} \label{line:insrv:c3e}
			\EndIf
			\State \Call{Rotate}{$z, \V{sideY}$} \Comment{Caso 2.} \label{line:insrb:c2b}
			\State $\Call{Active}{z}.\red = \True$ \label{line:insrb:act1}
			\State $\Call{Active}{y}.\red = \False$ \label{line:insrb:act2}
			\State \Break \label{line:insrb:c2e}
		\EndIf
	\EndWhile
	\State $\roots[\cur].\red = \False$ \Comment{Caso a raiz tenha sido pintada de vermelha.} \label{line:insrb:loope}
\EndFunction
\end{algorithmic}
\caption{Inserção em árvore rubro-negra parcialmente persistente.} \label{lst:ins_rb}
\end{algorithm}

O Código~\ref{lst:ins_rb} mostra então a implementação da inserção, como discutida, dado que a função~\mbox{\textsc{Rotate}} funciona corretamente. As linhas~\nref{line:insrb:insb}-\nref{line:insrb:inse} inserem o nó na árvore como em uma ABB normal, mas usando as funções~\textsc{Child} e~\textsc{Modify} para manter a persistência. As linhas~\nref{line:insrb:loopb}-\nref{line:insrb:loope} fazem o laço discutido nesta seção.

No começo da primeira iteração do laço, as propriedades valem pois~$x$ é um nó vermelho que recém-inserido. As linhas~\nref{line:insrb:xyzwb}-\nref{line:insrb:xyzwe} determinam os nós~$y$,~$z$ e~$w$, usados nos casos. O caso~1 é tratado nas linhas~\nref{line:insrb:c1b}-\nref{line:insrb:c1e}, trocando as cores de~$z$,~$y$ e~$w$ e fazendo o~$x$ da próxima iteração ser~$z$, pois é o único nó que possivelmente viola alguma propriedade.

O caso~3 é transformado no caso~2 nas linhas~\nref{line:insrb:c3b}-\nref{line:insrv:c3e}, fazendo uma rotação de~$y$ na direção de~$x$, e trocando esses~2 nós. As linhas~\nref{line:insrb:c2b}-\nref{line:insrb:c2e} então tratam o caso~2, fazendo uma rotação de~$z$ em direção à~$y$ e trocando a cor destes, como na Figura~\ref{fig:rb_ins_caso2}. As chamadas a~\textsc{Active} nas linhas~\nref{line:insrb:act1} e~\nref{line:insrb:act2} tratam o caso quando as rotações causaram cópias, e por isso~$y$ ou~$z$ não são mais ativos, pois para modificar o campo efêmero~$\red$ devemos modificar o nó ativo. Nestes dois casos o~\keyword{break} termina o laço.

Por último, a linha~\nref{line:insrb:loope} pinta a raiz de preto, já que o laço não trata esse caso e termina quando~$u$ não tem pai.

%% O(lgn) + O(1) amortizado
A função consome tempo amortizado~$\Oh(\lg n)$ pois a altura da árvore é~$\Oh(\lg n)$, ambos os lações das linhas~\nref{line:insrb:whilefind} e~\nref{line:insrb:loopb} realizam um número de iterações proporcional a altura, e a função~\textsc{Rotate} e~\textsc{Modify} consomem tempo (e espaço) amortizado constante. Como essas funções só são chamadas um número constante de vezes, o consumo de espaço é amortizado~$\Oh(1)$.

O Código~\ref{lst:rotrb} mostra a implementação da função~\textsc{Rotate}, que usa apenas um número constante de chamadas a~\textsc{Modify}. Note que é necessário, entre quaisquer duas chamadas, manter que cada nó tem no máximo um outro nó que aponta para ele, logo é preciso ter mais cuidado que com a implementação em uma ABB efêmera. Apesar das funções~\textsc{Child} e~\textsc{Modify} funcionarem se receberem nós que já foram copiados nesta operação, na função~\textsc{Rotate} é necessário acessar o campo~$\parent$ de~$u$, por isso na linha~\nref{line:rotrb:active} trocamos~$u$ por sua cópia, se existir.

\begin{algorithm}
\begin{algorithmic}[1]
\Require $u$ deve ter um filho~$\side$ na versão~$\cur$.
\Function{Rotate}{$u, \side$}
	\State $v = \Call{Child}{u, \side}$
	\State $\beta = \Call{Child}{v, \Not\ \side}$
	\State \Call{Modify}{$v, \Not\ \side, \Null$}
	\State \Call{Modify}{$u, \side, \beta$}
	\State $u = \Call{Active}{u}$ \label{line:rotrb:active}
	\If{$u.\parent \neq \Null$}
		\State \Call{Modify}{$u.\parent, [\Call{Child}{u.\parent, 1} = u], v$}
	\Else
		\State $\roots[\cur] = \Call{Active}{v}$ \Comment{Se~$u$ não tiver pai,~$u$ é a raiz.}
	\EndIf
	\State \Call{Modify}{$v, \Not\ \side, u$}
\EndFunction
\end{algorithmic}
\caption{Rotação em uma árvore rubro-negra parcialmente persistente.} \label{lst:rotrb}
\end{algorithm}

\section{Remoção em ABB}

Remover um nó é mais complicado que inserir, pois o nó que desejamos excluir pode ter filhos, então não basta removê-lo, temos que substituí-lo por algum de seus descendentes, e ainda manter as propriedades de uma ABB. Para remover o nó~$u$, temos dois casos.

Se~$u$ não tem filho direito, então podemos apenas substituí-lo por seu filho esquerdo (que pode ser~\keyword{null}), pois assim as propriedades de ABB continuam sendo seguidas.

Se~$u$ tem filho direito,~seja~$x$ o nó de menor valor na subárvore direita de~$u$ (ou seja, o nó com menor valor maior que o valor de~$u$). O nó~$x$ não tem filho esquerdo (ou existiria um nó com valor menor que o dele na mesma subárvore), logo podemos substituir~$x$ por seu filho direito, e substituir~$u$ por~$x$.

As propriedades de ABB continuam a ser seguidas pois todos os elementos da subárvore direita de~$u$ têm valores maiores ou iguais aos de~$x$ (pois este era o mínimo desta subárvore), e os elementos da subárvore esquerda de~$u$ tem valores menores ou iguais aos de~$x$ pois este era da subárvore direita de~$u$. No Código~\ref{lst:abb_remove}, assumimos que os nós têm ponteiro de pai em seu campo~$\parent$.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{MinElement}{$u$}
	\While{$u.\child[0] \neq \Null$}
		\State $u = u.\child[0]$
	\EndWhile
	\State \Return $u$
\EndFunction

\Function{Transplant}{$u, x$}
	\State $v = u.\parent$
	\If{$v \neq \Null$}
		\State $v.\child[[v.\child[1] = u]] = x$
	\Else
		\State $\V{root} = x$
	\EndIf
	\If{$x \neq \Null$}
		\State $x.\parent = v$
	\EndIf
\EndFunction

\Require{A árvore tem um nó com valor~$\val$.}
\Function{\API{Remove}}{$\val$}
	\State $u = \Call{Find}{\val}$ \label{line:rmabb:findb}
	\If{$u.\child[1] = \Null$} \label{line:rmabb:if1}
		\State \Call{Transplant}{$u, u.\child[0]$}
	\Else
		\State $x = \Call{MinElement}{u.\child[1]}$ \label{line:rmabb:minb}
		\State \Call{Transplant}{$x, x.\child[1]$}
		\State \Call{Transplant}{$u, x$}
		\State $x.\child = u.\child$ \label{line:rmabb:cpchild}
	\EndIf
\EndFunction

\end{algorithmic}
\caption{Remoção em uma ABB efêmera e não rubro-negra.} \label{lst:abb_remove}
\end{algorithm}

A função~\Call{MinElement}{$u$} devolve um nó com menor valor da subárvore de~$u$. Pelas propriedades de uma ABB, este está na subárvore esquerda de~$u$ se esta existe, então o~\keyword{while} segue links de esquerda até encontrar o menor elemento.

A função~\Call{Transplant}{$u, x$} substitui o nó~$u$ pelo nó~$x$. Para fazer isso, ela faz o pai de~$u$ apontar para~$x$ em vez de~$u$ (tratando o caso quando~$u$ é raiz). A função não modifica os filhos de~$u$ ou~$x$.

A linha~\nref{line:rmabb:findb} busca pelo nó~$u$ com valor~$\val$. O~\keyword{if} da linha~\nref{line:rmabb:if1} trata o caso em que~$u$ não tem filho direito, substituindo-o por seu filho esquerdo, usando a função~\textsc{Transplant}. Note que, ao final da função, o nó~$u$ aponta para um filho que não tem ponteiro de pai para~$u$, mas isto não é um problema pois o nó~$u$ foi removido da árvore.

Se~$u$ tem filho direito, a linha~\nref{line:rmabb:minb} busca o nó~$x$, mínimo da subárvore direita de~$u$. Este nó é trocado por seu filho direito e~$u$ é trocado por este nó. Após a chamada de~\Call{Transplant}{$u, x$}, o nó~$x$ é inválido pois, apesar de estar no lugar de~$u$, tem ponteiros em~$\child$ que não são válidos, por isso a linha~\nref{line:rmabb:cpchild} copia os filhos de~$u$ para~$x$. Note que o código funciona mesmo quando~$x$ é o próprio filho direito de~$u$.

\section{Remoção em rubro-negra}

Para remover um nó de uma árvore rubro-negra, fazemos como em uma ABB normal, mas é necessário se preocupar com as propriedades rubro-negras. Quando~$u$ tem filho direito, ao substituir~$u$ por~$x$, podemos copiar a cor de~$u$ para~$x$, e assim essa operação não viola nenhuma propriedade local a~$u$. Porém, a substituição de~$x$ por seu filho direito ou, no caso em que~$u$ não tem filho direito, a substituição de~$u$ por seu filho esquerdo, podem causar violações das propriedades em torno de~$x$ e~$u$. Nesses casos, porém, como~$x$ ou~$u$ não tem um dos filhos, a estrutura da subárvore é bem simples. Trataremos o caso de~$u$ não ter filho direito, o outro caso é simétrico.

\begin{figure}
\centering
\begin{tikzpicture}

\begin{scope}
	\Tree [.\node[b]{$u$}; ]
	\node[n, yshift=-2cm]{(a)};
\end{scope}
\begin{scope}[xshift=5cm]
	\Tree [.\node[r]{$u$}; ]
	\node[n, yshift=-2cm]{(b)};
\end{scope}
\begin{scope}[xshift=10cm]
	\Tree [.\node[b]{$u$}; \node[r]{}; \edge[n];\node[n]{}; ]
	\node[n, yshift=-2cm]{(c)};
\end{scope}

\end{tikzpicture}
\caption{Possíveis subárvores rubro-negras com raiz~$u$ que não tem filho direito.} \label{fig:rbnorchild}
\end{figure}

Pelas propriedades~2 e~3, quando um nó~$u$ não tem o filho direito, a estrutura de sua subárvore pode ser apenas uma das três ilustradas na Figura~\ref{fig:rbnorchild}.
Se a versão~\Call{Transplant}{$u, x$} de árvores rubro-negras também copiar a cor de~$u$ para~$x$, caso este não seja nulo, todas as propriedades rubro-negras continuam a ser respeitadas nas árvores~(b) e~(c), quando~$u$ é substituído por seu filho esquerdo. Na árvore~(a),~$u$ é removido e substituído por~\keyword{null}, logo os caminhos até links nulos que passavam por~$u$ agora têm um nó negro a menos, exceto se~$u$ for a raiz. Nesse caso, a árvore final é vazia e segue todas as propriedades.
Usamos então a função auxiliar~\textsc{AddBlack}, que arruma a violação da propriedade 3, e será discutida na próxima seção.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{MinElement}{$u$}
	\While{$\Call{Child}{u, 0} \neq \Null$}
		\State $u = \Call{Child}{u, 0}$
	\EndWhile
	\State \Return $u$
\EndFunction

\Function{Transplant}{$u, x$}
	\State $x = \Call{Active}{x}$
	\If{$x \neq \Null \AND x.\parent \neq \Null$} \Comment{Removendo link para~$x$, se houver.}
		\State \Call{Modify}{$x.\parent, [\Call{Child}{x.\parent, 1} = x], \Null$}
	\EndIf
	\State $u = \Call{Active}{u}$ \label{line:rmrb:activeu}
	\State $v = u.\parent$
	\If{$v \neq \Null$}
		\State $\Call{Modify}{v, [\Call{Child}{v, 1} = u], x}$
	\Else
		\State $\roots[\cur] = x$
	\EndIf
	\If{$x \neq \Null$}
		\State $x.\red = u.\red$
	\EndIf
\EndFunction

\Require{A árvore tem um nó com valor~$\val$.}
\Function{\API{Remove}}{$\val$}
	\State $\cur = \cur + 1$
	\State $\roots[\cur] = \roots[\cur - 1]$
	\State $u = \funcAPI{Find}{\val, \cur}$ \label{line:rmrb:find}
	\State $v = u.\parent$
	\If{$\Call{Child}{u, 1} = \Null$} \label{line:rmrb:if1}
		\State $\V{needFix} = (v \neq \Null \AND \Not\ u.\red \AND \Call{Child}{u, 0} = \Null)$
		\State \Call{Transplant}{$u, \Call{Child}{u, 0}$}
		\If{$\V{needFix}$}
			\State \Call{AddBlack}{$v, [\Call{Child}{v, 1} = \Null]$} \label{line:rmrb:addblack1}
		\EndIf
	\Else
		\State $x = \Call{MinElement}{\Call{Child}{u, 1}}$ \label{line:rmrb:minb}
		\If{$x = \Call{Child}{u, 1}$} \label{line:rmrb:if2}
			\State $y = x$
		\Else
			\State $y = x.\parent$
		\EndIf
		\State $\V{needFix} = (\Not\ x.\red \AND \Call{Child}{x, 1} = \Null)$
		\State \Call{Transplant}{$x, \Call{Child}{x, 1}$}
		\State \Call{Transplant}{$u, x$}
		\For{$\side \in \{0, 1\}$} \label{line:rmrb:cpchild}
			\State $\V{child} = \Call{Child}{u, \side}$
			\State \Call{Modify}{$u, \side, \Null$}
			\State \Call{Modify}{$x, \side, \V{child}$}
		\EndFor
		\If{$\V{needFix}$}
			\State \Call{AddBlack}{$y, [\Call{Child}{y, 1} = \Null]$}
		\EndIf
	\EndIf
\EndFunction

\end{algorithmic}
\caption{\textsc{Remove} em árvore rubro-negra parcialmente persistente.} \label{lst:remove_rb}
\end{algorithm}

O Código~\ref{lst:remove_rb} mostra a implementação da remoção, e funciona de forma similar a de uma ABB qualquer. A operação~\API{Find} é usada para encontrar um nó com valor~$\val$. A função~\textsc{MinElement} funciona como anteriormente, mas usando~\textsc{Child} para acessar os filhos. Já~\Call{Transplant}{$u, x$} foi modificada para remover o ponteiro que aponta para~$x$, caso esse exista. Isto faz diferença no caso da ABB (parcialmente) persistente pois queremos manter a propriedade de que no máximo um nó aponta para~$x$ a cada passo. A função~\textsc{Transplant} também copia a cor de~$u$ para~$x$, caso este não seja nulo.

Se~$u$ não tem filho direito, no~\keyword{if} da linha~\nref{line:rmrb:if1} este é trocado pelo seu filho esquerdo e, como discutido, se~$u$ é preto e não tem filho esquerdo, ocorre uma violação da propriedade~3 (a menos que~$u$ seja a raiz), que é então consertada por~\textsc{AddBlack}. Esta função recebe um nó e qual a direção do filho que deveria ser preto; isso é feito pois esse filho pode na verdade ser um link nulo. A função então modifica a árvore, rotacionando e mudando cores, de forma a remover a violação   da propriedade~3. Discutiremos a implementação desta função nas próximas subseções.

Se~$u$ tem filho direito, o processo funciona assim como em uma~ABB qualquer, mas chamamos~\textsc{AddBlack} caso a substituição de~$x$ tenha causado uma violação. O nó~$y$ é o pai de~$x$, exceto quando~$x$ é o próprio filho direito de~$u$, pois neste caso~${x.\parent = u}$ no começo do bloco, mas o nó~$u$ será substituído pelo nó~$x$, logo fazemos~$y = x$, pois este será o nó que aponta para o link nulo que deveria ser preto (se a função~\textsc{AddBlack} for chamada).

\subsection{Subindo violações}

Na função~\Call{AddBlack}{$y, \side$}, assim como no final da inserção, teremos um laço que, a cada iteração, ou termina com todas as violações, ou de certa forma ``sobe'' essas violações. A violação é da propriedade~3, pois todos os caminhos de~$y$ a links nulos seguindo seu filho~$\side$ têm um nó negro a menos que os caminhos passando por seu outro filho.

Seja~$x$ o filho de~$y$ na direção~$\side$ (pode ser nulo), e~$z$ seu filho na outra direção. Então se~$x$ existe e é vermelho, basta pintá-lo de preto e a propriedade~3 voltará a ser satisfeita. Caso contrário consideraremos alguns casos. Note que o filho~$z$ sempre existe, pois os caminhos começando em~$y$ e indo na direção de~$z$ precisam ter pelo menos um nó negro. Sejam~$z_x$ e~$z_z$ os filhos de~$z$ do lado~$\side$ e do outro lado, respectivamente.

\tikzset{
anyc/.style = {pattern=dots, pattern color=black},
banyc/.style = {pattern=dots, pattern color=black, preaction={fill, gray}}
}
%%% CASO 1
\begin{figure}
\centering
\begin{tikzpicture}

\begin{scope}
	\Tree [.\node[anyc]{$y$}; \node[b]{$x$}; [.\node[b]{$z$}; \node[b]{$z_x$}; \node[b]{$z_z$}; ] ]
\end{scope}

\begin{scope}[xshift=8cm]
	\Tree [.\node[banyc]{$y$}; \node[b]{$x$}; [.\node[r]{$z$}; \node[b]{$z_x$}; \node[b]{$z_z$}; ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~1, não importa se~$x$ é filho direito ou esquerdo.} \label{fig:rmrbc1}
\end{figure}
%%% CASO 2
\begin{figure}
\centering
\begin{tikzpicture}

\begin{scope}
	\Tree [.\node[anyc]{$y$}; \node[b]{$x$}; [.\node[b]{$z$}; \node[n]{$\alpha$}; \node[r]{$z_z$}; ] ]
\end{scope}

\begin{scope}[xshift=8cm]
	\Tree [.\node[anyc]{$z$}; [.\node[b]{$y$}; \node[b]{$x$}; \node[n]{$\alpha$}; ] \node[b]{$z_z$}; ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~2, assumindo que~$x$ é filho esquerdo.} \label{fig:rmrbc2}
\end{figure}
%%% CASO 3
\begin{figure}
\centering
\begin{tikzpicture}

\begin{scope}
	\Tree [.\node[anyc]{$y$}; \node[b]{$x$}; [.\node[b]{$z$}; [.\node[r]{$z_x$}; \node[n]{$\alpha$}; \node[n]{$\beta$}; ] \node[b]{$z_z$}; ] ]
\end{scope}

\begin{scope}[xshift=8cm]
	\Tree [.\node[anyc]{$y$}; \node[b]{$x$}; [.\node[b]{$z_x$}; \node[n]{$\alpha$}; [.\node[r]{$z$}; \node[n]{$\beta$}; \node[b]{$z_z$}; ] ] ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~3, assumindo que~$x$ é filho esquerdo.} \label{fig:rmrbc3}
\end{figure}
%%% CASO 4
\begin{figure}
\centering
\begin{tikzpicture}

\begin{scope}
	\Tree [.\node[b]{$y$}; \node[b]{$x$}; [.\node[r]{$z$}; \node[b]{$z_x$}; \node[b]{$z_z$}; ] ]
\end{scope}

\begin{scope}[xshift=8cm]
	\Tree [.\node[b]{$z$}; [.\node[r]{$y$}; \node[b]{$x$}; \node[b]{$z_x$}; ] \node[b]{$z_z$}; ]
\end{scope}

\draw[->] (2.5cm, -1cm) -- (5.5cm, -1cm);

\end{tikzpicture}
\caption{Aplicação do caso~4, assumindo que~$x$ é filho esquerdo.} \label{fig:rmrbc4}
\end{figure}

\begin{description}
	\item[Caso 1.] $z$ é preto,~$z_x$ e~$z_z$ ou não existem ou são negros.

	A Figura~\ref{fig:rmrbc1} mostra esse caso. O nó pontilhado indica que este nó pode ser tanto vermelho quanto negro. Todas as figuras assumem que~$x$ é filho esquerdo. O nó~$x$ pode não existir, este representa apenas uma direção a partir de~$y$.

	Pintamos~$z$ de vermelho e~$y$ de preto. Dessa forma, como os filhos de~$z$ são negros (ou não existem), a propriedade~2 não é quebrada, e temos um nó negro a mais nos caminhos que passam por~$y$ e~$x$. Se~$y$ é vermelho, o laço termina pois todas as propriedades foram restauradas, caso contrário, não é possível pintar~$y$ de preto duas vezes, e os caminhos que vão do pai de~$y$ para~$y$ têm um preto a menos. Assim, recomeçamos o laço trocando~$y$ por seu pai e~$\side$ pelo lado apropriado.

	Se~$y$ for a raiz, o pai desta é~\keyword{null}, e o laço deve acabar neste caso, já que não é um problema todos os caminhos a partir da raiz terem um preto a menos. Isso apenas significa que a altura negra (quantidade de nós negros dos caminhos da raiz até qualquer link nulo) da árvore diminui após esta remoção. % TODO: traduzir link

	\item[Caso 2.] $z$ é preto, $z_z$ é vermelho.

	Rotacionamos~$y$ em direção a~$z$, trocamos a cor destes dois nós e pintamos~$z_z$ de preto. A Figura~\ref{fig:rmrbc2} ilustra esse caso. Note que os caminhos nesta subárvore que passam por~$\alpha$ e~$z_z$ contém o mesmo número de nós negros (independentemente da cor de~$y$), e os caminhos que passam por~$x$ têm um nó negro a mais. Logo, a propriedade~3 volta a valer. Além disso, a propriedade~2 continua valendo pois os nós modificados são negros, exceto talvez por~$z$, mas este tem a mesma posição e cor que~$y$, e a propriedade~2 não era violada no início da iteração, logo continua não violada.

	\item[Caso 3.] $z$ é preto,~$z_x$ é vermelho e~$z_z$ é preto ou não existe.

	Rotacionamos~$z$ em direção a~$z_x$, e trocamos a cor destes dois nós. A Figura~\ref{fig:rmrbc3} ilustra esse caso. Note que os caminhos que passam por~$\alpha$,~$\beta$ e~$z_z$ continuam com o mesmo número de nós negros, logo a propriedade~3 não é violada nesses nós (mas continua sendo violada por~$x$). Após estas modificações, o caso~2 pode ser aplicado, já que~$x$ tem um irmão negro~(este nó é~$z_z$) com filho do lado contrário a~$x$ vermelho~(este nó é~$z$).

	\item[Caso 4.] $z$ é vermelho.

	Como os caminhos até links nulos de~$y$ na direção de~$z$ têm pelo menos um nó negro,~$z_x$ e~$z_y$ existem e são negros (já que a propriedade~2 não é violada). Além disso,~$y$ é preto (já que~$z$ é vermelho). Assim, rotacionamos~$y$ na direção de~$z$ e trocamos a cor destes dois nós. Note que os caminhos que passam por~$x$,~$z_x$ e~$z_z$ continuam com o mesmo número de nós negros.

	A Figura~\ref{fig:rmrbc4} ilustra esse caso. O novo irmão de~$x$ é preto (este nó é~$z_x$), e por isso algum dos outros casos~(1, 2, ou 3) se aplica. Note que, se o caso~1 se aplica, como~$y$ é vermelho, este pode ser pintado de preto, e por isso o laço termina após a aplicação deste caso.


\end{description}

Não é imediatamente claro que os~quatro casos cobrem todas as possibilidades. Como discutido, existe pelo menos um nó negro em todos os caminhos que passam por~$y$ em direção a~$z$, logo~$z$ existe. Se~$z$ é vermelho, estamos no caso~4. Caso contrário,~$z$ é preto. Se os filhos de~$z$ são ambos negros ou não existem (note que, pela propriedade~3, não é possível que um não exista e o outro seja preto), estamos no caso~1. Caso contrário, algum dos filhos de~$z$ é vermelho (ou ambos). Se~$z_z$ é vermelho, estamos no caso~2, e caso contrário~$z_x$ é vermelho e~$z_z$ não, logo estamos no caso~4.

Portanto, sempre um dos casos é aplicável. Se o caso~1 é aplicado, algumas mudanças de cores são feitas; se~$y$ era vermelho o laço termina, e caso contrário o laço continua, mas a altura de~$y$ diminui. Se o caso~2 é aplicado, as violações são removidas e o laço termina. Se o caso~3 é aplicado, segue uma imediata aplicação do caso~2 e o laço também termina. Se o caso~4 é aplicado, segue uma aplicação de algum dos outros casos. Se esta aplicação for do caso~2 ou~3, o laço termina depois de algumas rotações. Se for uma aplicação do caso~1, como~$y$ é vermelho após a aplicação do caso~4, o laço vai terminar após este caso.

Dessa forma, exceto por mudanças de cor, apenas um número constante de mudanças de campos são feitas durante uma remoção, para substituir o nó no começo da remoção e para terminar o laço durante a chamada de~\textsc{AddBlack}. Portanto, usando~\textsc{Child} e~\textsc{Modify} para manter a persistência (parcial), a operação de remoção consome tempo~$\Oh(\lg n)$ e espaço~$\Oh(1)$.

\begin{algorithm}
\begin{algorithmic}[1]

\Function{AddBlack}{$y, \side$}
	\State $y = \Call{Active}{y}$ \Comment{Versão mais atual de~$y$.}
	\While{$y \neq \Null$}
		\State $z = \Call{Child}{y, \Not\ \side}$
		\If{$z.\red$} \Comment{Arrumando caso~4 para caso~1,~2 ou~3.}
			\State \Call{Swap}{$y.\red, z.\red$} \Comment{Trocando cores.}
			\State \Call{Rotate}{$y, \Not\ \side$}
			\State $y = \Call{Active}{y}$
			\State $z = \Call{Child}{y, \Not\ \side}$
		\EndIf
		\State $z_x = \Call{Child}{z, \side}$
		\State $z_z = \Call{Child}{z, \Not\ \side}$
		\If{$(z_x = \Null \Or \Not\ z_x.\red) \AND (z_z = \Null \Or \Not\ z_z.\red)$} \Comment{Caso 1.}
			\State $z.\red = \True$
			\If{$y = \roots[\cur] \Or y.\red$}
				\State $y.\red = \False$
				\State \Break
			\Else
				\State $\side = [\Call{Child}{y.\parent, 1} = y]$
				\State $y = y.\parent$
			\EndIf
		\Else
			\If{$z_x \neq \Null \AND z_x.\red$} \Comment{Arrumando caso~3 para caso~2.}
				\State \Call{Swap}{$z.\red, z_x.\red$}
				\State \Call{Rotate}{$z, \side$}
				\State $y = \Call{Active}{y}$
				\State $z = \Call{Child}{y, \Not\ \side}$
				\State $z_z = \Call{Child}{z, \Not\ \side}$
			\EndIf
			\State \Call{Swap}{$y.\red, z.\red}$ \Comment{Caso 2.}
			\State $z_z.\red = \False$
			\State \Call{Rotate}{$y, \Not\ \side$}
			\State \Break
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\caption{Implementação de~\textsc{AddBlack}.} \label{lst:addblack}
\end{algorithm}

A implementação da função~\textsc{AddBlack} no Código~\ref{lst:addblack} segue os casos descritos nesta seção. É necessário cuidado ao modificar a cor de um nó, já que é necessário fazer essa modificação na versão mais atual do nó. Por isso, na aplicação dos casos, as mudanças de cores são feitas antes das rotações (que podem gerar cópias dos nós), e após as rotações as versões mais novas de cada nó são atualizadas.

A primeira coluna da Tabela~\ref{tab:arb_comp} mostra o consumo de tempo e espaço da implementação discutida neste capítulo.


\begin{table} \centering
\begin{tabular}{|l|c|c|}
	\hline
	& Node copying & Funcional \\ \hline
	\funcAPI{Insert}{\V{value}} & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ \\
	\funcAPI{Remove}{\V{value}} & $\Oh(\lg n) / \Oh(1)$ & $\Oh(\lg n) / \Oh(\lg n)$ \\
	\funcAPI{Find}{\V{value}} & $\Oh(\lg n)$ & $\Oh(\lg n)$ \\ \hline
\end{tabular}
	\caption{Comparação do consumo de tempo e espaço da solução implementada neste capítulo e de uma implementação funcional, feita como indicado na Seção~\ref{sec:implfuncional}, onde~$n$ é o tamanho da ABB. Note que a implementação deste capítulo é parcialmente persistente, enquanto a implementação funcional é totalmente persistente.} \label{tab:arb_comp}
\end{table}


\end{document}
