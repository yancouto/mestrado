\documentclass[main.tex]{subfiles}

\begin{document}

\chapter{Pilhas e filas de acesso aleatório} \label{cap:pilha_persist}
Pilhas são uma das estruturas de dados mais simples. Uma pilha é \deff{de acesso aleatório} se permite acesso a qualquer elemento seu, não só o topo. Discutiremos neste capítulo como transformá-las em estruturas persistentes. Em nosso pseudocódigo, usaremos estruturas de dados como objetos. As operações aplicadas sobre uma ED são funções que recebem essa ED como argumento (além de possíveis argumentos adicionais). Além disso, existe uma operação que devolve uma ED vazia.

Para manipular estruturas persistentes, é conveniente que, ao chamar uma operação de modificação, uma nova versão da ED seja devolvida, e a versão anterior continue válida, ou seja, continue podendo ser usada para operações de acesso, ou de modificação. O estado da versão anterior pode mudar, mas a resposta para qualquer operação de acesso deve ser a mesma. Assim, nesse contexto, uma pilha de acesso aleatório é uma lista de elementos, que permite as seguintes operações:

\begin{itemize}
	\item \funcAPI{Stack}{}
		\\ Devolve uma pilha vazia.
	\item \funcAPI{Push}{p, x}
		\\ Devolve uma cópia da pilha~$p$ com o valor~$x$ inserido em seu fim.
	\item \funcAPI{Pop}{p}
		\\ Devolve uma cópia da pilha~$p$ com seu último elemento removido.
	\item \funcAPI{Size}{p}
		\\ Devolve o número de elementos na pilha~$p$.
	\item \funcAPI{Top}{p}
		\\ Devolve o último elemento da pilha~$p$.
	\item \funcAPI{k-th}{p, k}
		\\ Devolve o $k$-ésimo elemento da pilha~$p$.
\end{itemize}

As operações são o meio com o qual o ``usuário'' lida com a ED, no resto do capítulo descreveremos como implementar tais operações. Para deixar clara a notação, operações são \underline{sublinhadas} e funções auxiliares (que usamos para nos ajudar a implementar as operações) não são.

Na literatura, é usual chamar o último elemento de uma pilha de~\emph{topo}, porém, como a operação~\API{k-th} necessita que os elementos tenham uma ordem e sentido, deixamos claro na descrição das operações qual é o primeiro e o último elemento.

Temos que~\funcAPI{Push}{p, x} e~\funcAPI{Pop}{p} são operações de modificação, enquanto~\funcAPI{Top}{p},~\funcAPI{k-th}{p, k} e~\funcAPI{Size}{p} são operações de acesso.

\section{Persistência total}

Para implementar uma pilha persistente, utilizaremos a implementação de pilhas usando lista ligada. Essa implementação consiste de vários nós, cada um com três campos:~\code{val}, com o valor armazenado neste nó,~\code{next}, com um ponteiro para o próximo nó na lista e~\code{size} com o tamanho da lista começando naquele nó. O último nó da lista ligada tem como seu campo~\code{next} um valor especial~\keyword{null}, que indica que este é o último nó da lista.

Uma pilha pode ser representada pelo nó correspondente ao começo de sua lista. Note que o campo~\code{val} do primeiro nó da lista é o último elemento da pilha, e assim por diante. Considere que estamos apenas fazendo uma pilha, sem preocupação com persistência.
Para realizar a operação~\funcAPI{Push}{p, x}, basta criar um novo nó com valor~$x$ e fazer seu campo~\code{next} apontar para o começo anterior da lista. O novo nó passa a ser o novo começo da lista. Para realizar a operação~\funcAPI{Top}{p}, basta devolver o campo~\code{val} do nó do começo, e para realizar~\funcAPI{Pop}{p}, consideramos que o novo começo é o nó apontado pelo campo~\code{next} do começo anterior.

Perceba que nunca é necessário mudar os campos de algum nó já criado; em particular, efetivamente não se remove da lista nenhum nó. Nesse caso, se guardarmos em~$p_i$ o nó do começo da lista na~$i$-ésima versão, os nós~\emph{acessíveis a partir de~$p_i$} e os campos destes não mudarão mesmo com as operações realizadas em versões futuras. Portanto é possível realizar operações de acesso e modificação em versões anteriores da estrutura, e esta então é uma estrutura persistente.

Implementações de estruturas como esta, nas quais operações de modificação nunca mudam nenhum valor existente da ED, apenas criam valores novos, são chamadas de~\deff{funcionais}. Como qualquer valor acessível a partir de uma versão antiga continua o mesmo, estas estruturas são sempre persistentes. Note que, diferente de implementações usuais, não é permitido apagar valores que não serão mais usados na versão atual. Dizemos que a versão atual é a última versão criada por alguma operação de modificação.

O Código~\ref{lst:pilhapersist} mostra a implementação de tal pilha persistente. Usamos que~{\keyword{new}~\func{Node}{x, nx, sz}} cria um novo nó com campos~$\V{val} = x$,~$\V{next} = \V{nx}$ e~$\V{size} = \V{sz}$. Note que ignoramos a operação~\funcAPI{k-th}{p, k} por ora, mas voltaremos a discutir esta na Seção~\ref{sec:pilha_persist_kth}.


\begin{algorithm}
\caption{Pilha persistente.} \label{lst:pilhapersist}
\begin{algorithmic}[1]

\Function{\underline{Stack}}{\null}
	\State \Return \Null
\EndFunction

\Function{\underline{Size}}{p}
	\If{$p = \Null$}
		\State \Return $0$
	\Else
		\State \Return $p.\V{size}$
	\EndIf
\EndFunction

\Function{\underline{Push}}{$p, x$}
	\State \Return \New \func{Node}{x, p, \funcAPI{Size}{p} + 1}
\EndFunction

\Function{\underline{Top}}{$p$}
	\State \Return $p.\V{val}$
\EndFunction

\Function{\underline{Pop}}{$p$}
	\State \Return $p.\V{next}$
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Exemplo}

Vamos considerar a sequência de operações no Exemplo~\ref{ex:pilha}. Na esquerda temos as operações realizadas, e na direita as novas pilhas criadas, ou o valor devolvido pela operação~\funcAPI{Top}{p}.

\begin{example}
\centering

\begin{subalgorithm}{0.4\textwidth}
\begin{algorithmic}

\State $p_0 =$ \funcAPI{Stack}{}
\State $p_1 =$ \funcAPI{Push}{p_0, 5}
\State $p_2 =$ \funcAPI{Push}{p_1, 7}
\State $p_3 =$ \funcAPI{Push}{p_2, 6}
\State $p_4 =$ \funcAPI{Pop}{p_2}
\State \funcAPI{Top}{p_3}
\State $p_5 =$ \funcAPI{Push}{p_4, 9}
\State \funcAPI{Top}{p_4}
\State $p_6 =$ \funcAPI{Push}{p_0, 5}

\end{algorithmic}
\end{subalgorithm} \vrule
\begin{subalgorithm}{0.4\textwidth}
\begin{algorithmic}

\State $p_0:$
\State $p_1:$ 5
\State $p_2:$ 5 7
\State $p_3:$ 5 7 6
\State $p_4:$ 5
\State Devolve 6
\State $p_5:$ 5 9
\State Devolve 5
\State $p_6:$ 5

\end{algorithmic}
\end{subalgorithm}
\caption{Exemplo de uso de uma pilha persistente.} \label{ex:pilha}
\end{example}

Em uma pilha efêmera (não-persistente) adicionamos apenas elementos no começo da lista ligada, mas no caso da pilha persistente podemos adicionar nós em outros pontos, e na verdade a estrutura resultante é uma arborescência, ou seja, uma árvore enraizada onde as arestas apontam para a raiz, considerando que o apontador da raiz é~\keyword{null}. Note que, como discutido anteriormente, a partir de cada nó podemos apenas acessar uma lista, se considerarmos seus campos~\code{next}.

A Figura~\ref{fig:pilha_ex1} mostra a arborescência criada para a sequência de operações do Exemplo~\ref{ex:pilha}. Em cada nó é indicado o valor armazenado naquele nó, e a flecha saindo de cada nó indica seu campo~$\V{next}$. Os valores~$p_0, \ldots, p_6$ apontam para os seus nós correspondentes. Note que é possível que~${p_i = p_j}$ para~${i \neq j}$. Isso ocorre no exemplo, onde~$p_4 = p_1$. Isso não ocorre sempre que as pilhas têm os mesmos valores; perceba que~$p_1 \neq p_6$, apesar destas duas pilhas terem os mesmos elementos na mesma ordem.

Perceba também que a árvore de versões não é igual à árvore da estrutura. A Figura~\ref{fig:pilha_ex2} mostra a árvore de versões para essa sequência de operações. Nos nós estão os índices das versões~(a~$i$-ésima modificação cria a versão~$i$), e a versão~$i$ é o pai da versão~$j$ se a versão~$j$ foi criada usando a versão~$i$.

\begin{figure}
	\centering
	\begin{tikzpicture}[sibling distance=25pt, nodes={draw, minimum size=6mm}, edge from parent/.append style={<-, shorten <= 5pt, shorten >= 5pt}, level distance=40pt]
		\Tree [.\node[minimum size=6mm](root){};
			[.\node(p14){5}; [.\node(p2){7}; [.\node(p3){6}; ] ] \node(p5){9}; ]
			\node(p6){5};
		]
\draw (root.south west) edge (root.north east);
\draw[->, shorten >= 10pt] node[draw=none, left = 1cm of root]{$p_0$} edge (root);

\draw[->, shorten >= 10pt] node[draw=none, left = 1cm of p14,yshift=12pt]{$p_1$} edge (p14);
\draw[->, shorten >= 10pt] node[draw=none, left = 1cm of p14]{$p_4$} edge (p14);
\draw[->, shorten >= 10pt] node[draw=none, left = 1cm of p2]{$p_2$} edge (p2);
\draw[->, shorten >= 10pt] node[draw=none, left = 1cm of p3]{$p_3$} edge (p3);
\draw[->, shorten >= 10pt] node[draw=none, right = 1cm of p5]{$p_5$} edge (p5);
\draw[->, shorten >= 10pt] node[draw=none, right = 1cm of p6]{$p_6$} edge (p6);

	\end{tikzpicture}
	\caption{Arborescência criada pela sequência de operações do Exemplo~\ref{ex:pilha}.} \label{fig:pilha_ex1}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}[sibling distance=15pt]
		\Tree [.0
			[.1 [.2 3 [.4 5 ] ] ]
			6
		]
	\end{tikzpicture}
	\caption{Árvore de versões associada à sequência de operações do Exemplo~\ref{ex:pilha}.} \label{fig:pilha_ex2}
\end{figure}


\section{Acesso a outros elementos} \label{sec:pilha_persist_kth}

Apresentaremos a implementação da função~\funcAPI{k-th}{p, k}. Esta operação é uma generalização de~\funcAPI{Top}{p}, já que~${\funcAPI{Top}{p} = \funcAPI{k-th}{p, p.\V{size}}}$.

Lembre-se que~$p$ é um nó de uma arborescência, e representa o último elemento da pilha, então~\funcAPI{k-th}{p, k} precisa determinar o~$(p.\V{size}-k)$-ésimo ancestral de~$p$, ou seja, o nó alcançado a partir de~$p$ ao caminhar por~$p.\V{size} - k$ links~$\V{next}$. Nesse caso, o~0-ésimo ancestral de um nó é o próprio nó.

Note que esse é o problema do Ancestral de Nível, discutido nos Capítulos~\ref{cap:ancestrais} e~\ref{cap:skew}. Nesses capítulos foi discutido como encontrar ancestrais de níveis usando as operações~\funcAPI{AddLeaf}{u} e~\funcAPI{LevelAncestor}{u, k}. Note que apresentamos essas operações de forma que folhas novas possam ser adicionadas de forma online, que é necessário neste problema, já que adicionamos uma folha quando aplicamos uma operação de modificação à pilha.

\providecommand{\Par}{\operatorname{Parent}}

Se assumimos que a função~${\New \func{Node}{x, \V{nx}, \V{sz}}}$ também chama a operação~\funcAPI{AddLeaf}{u} para o novo nó criado, com~$\Par(u) = \V{nx}$, então o Código~\ref{lst:pilha-kth} implementa a operação~\funcAPI{k-th}{p, k}, e está trivialmente correto.

\begin{algorithm}
\begin{algorithmic}[1]
\Function{k-th}{$p, k$}
	\State \Return $\Call{LevelAncestor}{p, p.\V{size} - k}.\V{val}$
\EndFunction
\end{algorithmic}
\caption{Implementação de~\funcAPI{k-th}{p, k} usando~Level Ancestor como caixa preta.} \label{lst:pilha-kth}
\end{algorithm}

A Tabela~\ref{tab:pilha_persist} mostra o consumo de tempo e espaço de uma pilha persistente, usando o Ancestral de Nível do Capítulo~\ref{cap:ancestrais} e~\ref{cap:skew}.

\begin{table} \centering
\begin{tabular}{|l|c|c|}
	\hline
	& Representação Binária & Skew-Binary \\ \hline
	\funcAPI{Stack}{} & $\Oh(1) / \Oh(1)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Push}{p, x} & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Pop}{p} & $\Oh(1)$ & $\Oh(1)$ \\
	\funcAPI{Top}{p} & $\Oh(1)$ & $\Oh(1)$ \\
	\funcAPI{Size}{p} & $\Oh(1)$ & $\Oh(1)$ \\
	\funcAPI{k-th}{p, k} & $\Oh(\lg n)$ & $\Oh(\lg n)$ \\ \hline
\end{tabular}
	\caption{Consumo de tempo e espaço da implementação de uma pilha de acesso aleatório persistente, usando cada uma das implementações de Ancestral de Nível, onde~$n$ é o tamanho atual da pilha. \label{tab:pilha_persist}}
\end{table}

\section{Filas persistentes}

Filas são estruturas quase tão simples quanto pilhas. Elas também são listas, e permitem inserções no final e remoções no começo. Mais precisamente, filas de acesso aleatório permitem as seguintes operações:

\begin{itemize}
	\item \funcAPI{Queue}{}
		\\ Devolve uma fila vazia.
	\item \funcAPI{Enqueue}{q, x}
		\\ Devolve uma cópia da fila~$q$ com o valor~$x$ inserido em seu fim.
	\item \funcAPI{Dequeue}{q}
		\\ Devolve uma cópia da fila~$q$ com seu primeiro elemento removido.
	\item \funcAPI{First}{q}
		\\ Devolve o primeiro elemento da fila~$q$.
	\item \funcAPI{k-th}{q, k}
		\\ Devolve o~\mbox{$k$-ésimo} elemento da fila~$q$.
\end{itemize}

É possível, como com pilhas, implementar uma fila usando lista ligada. A lista torna-se uma árvore quando se adiciona a persistência. Seria então necessário usar a solução para o problema do~Ancestral de Nível nas operações~\funcAPI{k-th}{q, k} e~\funcAPI{Last}{q}.

Utilizaremos, entretanto, as próprias funções de pilha para implementar uma fila. Uma fila é representada por um par em que o primeiro elemento é uma pilha e o segundo é o número de elementos que já foram removidos da fila. No pseudocódigo, usaremos que~$(p,\,r)$ cria um par ordenado contendo a pilha~$p$ e um inteiro~$r$, e todo par tem os campos~$\V{stack}$ e~$\V{rem}$ contendo cada um de seus elementos.
Assumimos que criar pares, e devolvê-los por função, consome tempo constante.


\begin{algorithm}
\begin{algorithmic}[1]
\Function{\underline{Queue}}{\null}
	\State \Return $(\Null,\,0)$
\EndFunction

\Function{\underline{Enqueue}}{$q, x$}
	\State \Return $(\Call{Push}{q.\V{stack}, x},\,q.\V{rem})$
\EndFunction

\Function{\underline{Dequeue}}{$q$}
	\State \Return $(q.\V{stack},\,q.\V{rem} + 1)$
\EndFunction

\Function{\underline{First}}{$q$}
	\State \Return $\funcAPI{k-th}{q.\V{stack}, q.\V{rem} + 1}$ \Comment{Função homônima da pilha}
\EndFunction

\Function{\underline{k-th}}{$q, k$}
	\State \Return $\funcAPI{k-th}{q.\V{stack}, q.\V{rem} + k}$ \Comment{Função homônima da pilha}
\EndFunction

\end{algorithmic}
\caption{Fila de acesso aleatório persistente.} \label{lst:fila}
\end{algorithm}

O Código~\ref{lst:fila} mostra a implementação das operações da fila. A correção segue diretamente da correção das funções para pilha. De fato, podendo acessar qualquer elemento de uma pilha, implementar uma fila é simples, já que usamos apenas as operações~\textsc{Push} e~\textsc{k-th}, e simplesmente ignoramos os elementos que existem antes do começo da fila.

%Sempre assumimos que todas as chamadas de operações são válidas, ou seja, nunca haverá uma chamada para~\funcAPI{k-th}{q, k} com~$k$ maior que o tamanho de~$q$, de modo que os elementos antes do começo da fila nunca serão acessados indevidamente.

Desde que a implementação da pilha seja persistente, a implementação da fila é persistente pois nunca modifica nenhum par, apenas cria novos objetos. A Tabela~\ref{tab:fila_persist} mostra o consumo de tempo e espaço da implementação discutida neste capítulo.

\begin{table} \centering
\begin{tabular}{|l|c|c|}
	\hline
	& Representação Binária & Skew-Binary \\ \hline
	\funcAPI{Queue}{} & $\Oh(1) / \Oh(1)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Enqueue}{q, x} & $\Oh(\lg n) / \Oh(\lg n)$ & $\Oh(1) / \Oh(1)$ \\
	\funcAPI{Dequeue}{q} & $\Oh(1)$ & $\Oh(1)$ \\
	\funcAPI{First}{q} & $\Oh(\lg n)$ & $\Oh(\lg n)$ \\
	\funcAPI{k-th}{q, k} & $\Oh(\lg n)$ & $\Oh(\lg n)$ \\ \hline
\end{tabular}
	\caption{Consumo de tempo e espaço da implementação de uma fila de acesso aleatório persistente, usando cada uma das implementações de pilha persistente, onde~$n$ é o tamanho atual da fila. \label{tab:fila_persist}}
\end{table}

\end{document}
